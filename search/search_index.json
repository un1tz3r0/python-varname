{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"[ ] 15 [ ] 13 [ ] 13 [ ] 18 Dark magics about variable names in python Change Log | API | Playground Installation pip install -U varname Features Core features: Retrieving names of variables a function/class call is assigned to from inside it, using varname . Retrieving variable names directly, using nameof Detecting next immediate attribute name, using will Fetching argument names/sources passed to a function using argname Other helper APIs (built based on core features): A value wrapper to store the variable name that a value is assigned to, using Wrapper A decorator to register __varname__ to functions/classes, using register A debug function to print variables with their names and values Credits Thanks goes to these awesome people/projects: @alexmojaki @breuleux executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project. Usage Retrieving the variable names using varname(...) From inside a function from varname import varname def function (): return varname () func = function () # func == 'func' When there are intermediate frames: def wrapped (): return function () def function (): # retrieve the variable name at the 2nd frame from this one return varname ( frame = 2 ) func = wrapped () # func == 'func' Or use ignore to ignore the wrapped frame: def wrapped (): return function () def function (): return varname ( ignore = wrapped ) func = wrapped () # func == 'func' Calls from standard libraries are ignored by default: import asyncio async def function (): return varname () func = asyncio . run ( function ()) # func == 'func' Use strict to control whether the call should be assigned to the variable directly: def function ( strict ): return varname ( strict = strict ) func = function ( True ) # OK, direct assignment, func == 'func' func = [ function ( True )] # Not a direct assignment, raises ImproperUseError func = [ function ( False )] # OK, func == ['func'] func = function ( False ), function ( False ) # OK, func = ('func', 'func') Retrieving name of a class instance class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied foo = Foo () # foo.id == 'foo' foo2 = foo . copy () # foo2.id == 'foo2' Multiple variables on Left-hand side # since v0.5.4 def func (): return varname ( multi_vars = True ) a = func () # a == ('a',) a , b = func () # (a, b) == ('a', 'b') [ a , b ] = func () # (a, b) == ('a', 'b') # hierarchy is also possible a , ( b , c ) = func () # (a, b, c) == ('a', 'b', 'c') Some unusual use def function ( ** kwargs ): return varname ( strict = False ) func = func1 = function () # func == func1 == 'func1' # if varname < 0.8: func == func1 == 'func' # a warning will be shown # since you may not want func to be 'func1' x = function ( y = function ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' The decorator way to register __varname__ to functions/classes Registering __varname__ to functions from varname.helpers import register @register def function (): return __varname__ func = function () # func == 'func' # arguments also allowed (frame, ignore and raise_exc) @register ( frame = 2 ) def function (): return __varname__ def wrapped (): return function () func = wrapped () # func == 'func' Registering __varname__ as a class property @register class Foo : ... foo = Foo () # foo.__varname__ == 'foo' Getting variable names directly using nameof from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , vars_only = False ) # 'func.a' func . a . b = 1 nameof ( func . a . b , vars_only = False ) # 'func.a.b' Detecting next immediate attribute name from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!' Fetching argument names/sources using argname from varname import argname def func ( a , b = 1 ): print ( argname ( 'a' )) x = y = z = 2 func ( x ) # prints: x def func2 ( a , b = 1 ): print ( argname ( 'a' , 'b' )) func2 ( y , b = x ) # prints: ('y', 'x') # allow expressions def func3 ( a , b = 1 ): print ( argname ( 'a' , 'b' , vars_only = False )) func3 ( x + y , y + x ) # prints: ('x+y', 'y+x') # positional and keyword arguments def func4 ( * args , ** kwargs ): print ( argname ( 'args[1]' , 'kwargs[c]' )) func4 ( y , x , c = z ) # prints: ('x', 'z') Value wrapper from varname.helpers import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False} Debugging with debug from varname.helpers import debug a = 'value' b = [ 'val' ] debug ( a ) # \"DEBUG: a='value'\\n\" debug ( b ) # \"DEBUG: b=['val']\\n\" debug ( a , b ) # \"DEBUG: a='value'\\nDEBUG: b=['val']\\n\" debug ( a , b , merge = True ) # \"DEBUG: a='value', b=['val']\\n\" debug ( a , repr = False , prefix = '' ) # 'a=value\\n' # also debug an expression debug ( a + a ) # \"DEBUG: a+a='valuevalue'\\n\" # If you want to disable it: debug ( a + a , vars_only = True ) # ImproperUseError Reliability and limitations varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # pytest manipulated the ast here # do this instead name_a = nameof ( a ) assert name_a == 'a'","title":"Home"},{"location":"#installation","text":"pip install -U varname","title":"Installation"},{"location":"#features","text":"Core features: Retrieving names of variables a function/class call is assigned to from inside it, using varname . Retrieving variable names directly, using nameof Detecting next immediate attribute name, using will Fetching argument names/sources passed to a function using argname Other helper APIs (built based on core features): A value wrapper to store the variable name that a value is assigned to, using Wrapper A decorator to register __varname__ to functions/classes, using register A debug function to print variables with their names and values","title":"Features"},{"location":"#credits","text":"Thanks goes to these awesome people/projects: @alexmojaki @breuleux executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project.","title":"Credits"},{"location":"#usage","text":"","title":"Usage"},{"location":"#retrieving-the-variable-names-using-varname","text":"From inside a function from varname import varname def function (): return varname () func = function () # func == 'func' When there are intermediate frames: def wrapped (): return function () def function (): # retrieve the variable name at the 2nd frame from this one return varname ( frame = 2 ) func = wrapped () # func == 'func' Or use ignore to ignore the wrapped frame: def wrapped (): return function () def function (): return varname ( ignore = wrapped ) func = wrapped () # func == 'func' Calls from standard libraries are ignored by default: import asyncio async def function (): return varname () func = asyncio . run ( function ()) # func == 'func' Use strict to control whether the call should be assigned to the variable directly: def function ( strict ): return varname ( strict = strict ) func = function ( True ) # OK, direct assignment, func == 'func' func = [ function ( True )] # Not a direct assignment, raises ImproperUseError func = [ function ( False )] # OK, func == ['func'] func = function ( False ), function ( False ) # OK, func = ('func', 'func') Retrieving name of a class instance class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied foo = Foo () # foo.id == 'foo' foo2 = foo . copy () # foo2.id == 'foo2' Multiple variables on Left-hand side # since v0.5.4 def func (): return varname ( multi_vars = True ) a = func () # a == ('a',) a , b = func () # (a, b) == ('a', 'b') [ a , b ] = func () # (a, b) == ('a', 'b') # hierarchy is also possible a , ( b , c ) = func () # (a, b, c) == ('a', 'b', 'c') Some unusual use def function ( ** kwargs ): return varname ( strict = False ) func = func1 = function () # func == func1 == 'func1' # if varname < 0.8: func == func1 == 'func' # a warning will be shown # since you may not want func to be 'func1' x = function ( y = function ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b'","title":"Retrieving the variable names using varname(...)"},{"location":"#the-decorator-way-to-register-__varname__-to-functionsclasses","text":"Registering __varname__ to functions from varname.helpers import register @register def function (): return __varname__ func = function () # func == 'func' # arguments also allowed (frame, ignore and raise_exc) @register ( frame = 2 ) def function (): return __varname__ def wrapped (): return function () func = wrapped () # func == 'func' Registering __varname__ as a class property @register class Foo : ... foo = Foo () # foo.__varname__ == 'foo'","title":"The decorator way to register __varname__ to functions/classes"},{"location":"#getting-variable-names-directly-using-nameof","text":"from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , vars_only = False ) # 'func.a' func . a . b = 1 nameof ( func . a . b , vars_only = False ) # 'func.a.b'","title":"Getting variable names directly using nameof"},{"location":"#detecting-next-immediate-attribute-name","text":"from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!'","title":"Detecting next immediate attribute name"},{"location":"#fetching-argument-namessources-using-argname","text":"from varname import argname def func ( a , b = 1 ): print ( argname ( 'a' )) x = y = z = 2 func ( x ) # prints: x def func2 ( a , b = 1 ): print ( argname ( 'a' , 'b' )) func2 ( y , b = x ) # prints: ('y', 'x') # allow expressions def func3 ( a , b = 1 ): print ( argname ( 'a' , 'b' , vars_only = False )) func3 ( x + y , y + x ) # prints: ('x+y', 'y+x') # positional and keyword arguments def func4 ( * args , ** kwargs ): print ( argname ( 'args[1]' , 'kwargs[c]' )) func4 ( y , x , c = z ) # prints: ('x', 'z')","title":"Fetching argument names/sources using argname"},{"location":"#value-wrapper","text":"from varname.helpers import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False}","title":"Value wrapper"},{"location":"#debugging-with-debug","text":"from varname.helpers import debug a = 'value' b = [ 'val' ] debug ( a ) # \"DEBUG: a='value'\\n\" debug ( b ) # \"DEBUG: b=['val']\\n\" debug ( a , b ) # \"DEBUG: a='value'\\nDEBUG: b=['val']\\n\" debug ( a , b , merge = True ) # \"DEBUG: a='value', b=['val']\\n\" debug ( a , repr = False , prefix = '' ) # 'a=value\\n' # also debug an expression debug ( a + a ) # \"DEBUG: a+a='valuevalue'\\n\" # If you want to disable it: debug ( a + a , vars_only = True ) # ImproperUseError","title":"Debugging with debug"},{"location":"#reliability-and-limitations","text":"varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # pytest manipulated the ast here # do this instead name_a = nameof ( a ) assert name_a == 'a'","title":"Reliability and limitations"},{"location":"CHANGELOG/","text":"v0.8.1 Handle inspect raises \"could not get source code\" when printing rich exception message v0.8.0 Compared to v0.7.3 - Add UsingExecWarning when exec is used to retrieve func for argname() . - Remove NonVariableArgumentError . Use ImproperUseError instead. - Add VarnameError and VarnameWarning as root for varname-related exceptions and warnings, respectively. - Default strict to True for varname() , helpers.register() and helpers.Wrapper() - Limit number of context lines for showing where ImproperUseError happens Compared to v0.7.0 - Add UsingExecWarning when exec is used to retrieve func for argname() . - Remove NonVariableArgumentError . Use ImproperUseError instead. - Add VarnameError and VarnameWarning as root for varname-related exceptions and warnings, respectively. - Add strict mode to varname() , helpers.register() and helpers.Wrapper() (#57) - Support the walrus operator ( := ) (#58) - Change argname() to accept argument names instead of arguments themselves - Remove pos_only argument from argname() - Add ignore argument to argname() to ignore intermediate frames - Limit VarnameRetrievingError to the situations only when the AST node is not able to be retrieved. v0.7.3 Indicate where the ImproperUseError happens for varname() (Close #60) Add VarnameException and VarnameWarning as root for all varname-defined exceptions and warnings. v0.7.2 Add strict mode to varname() (#57) Support the walrus operator ( := ) (#58) v0.7.1 Add ignore argument to argname2() Fix Fix utils.get_argument_sources() when kwargs is given as **kwargs . v0.7.0 ImproperUseError is now independent of VarnameRetrievingError Deprecate argname , superseded by argname2 >>> argname ( a , b , ... ) # before >>> argname2 ( 'a' , 'b' , ... ) # after Add dispatch argument to argname / argment2 to be used for single-dispatched functions. v0.6.5 Add sep argument to helpers.debug() v0.6.4 Add ImproperUseError to distinguish node retrieving error from improper varname use #49 v0.6.3 Fix standard library ignoring ignores 3rd-party libraries under site-packages/ Allow pathlib.Path object to be used in ignore items v0.6.2 Remove argument full for nameof , use vars_only instead. When vars_only=False , source of the argument returned. # before: nameof ( a . b , full = True ) # 'a.b' nameof ( x [ 0 ], full = True ) # unable to fetch # after (requires asttoken): nameof ( a . b , vars_only = False ) # 'a.b' nameof ( x [ 0 ], vars_only = False ) # 'x[0]' Add argument frame to argname , so that it can be wrapped. def argname2 ( arg , * more_args ): return argname ( arg , * more_args , frame = 2 ) Allow argname to fetch the source of variable keyword arguments ( **kwargs ), which will be an empty dict ( {} ) when no keyword arguments passed. def func ( a , ** kwargs ): return argname ( a , kwargs ) # before: func ( x ) # raises error # after: func ( x ) # returns ('x', {}) Add argument pos_only to argname to only match the positional arguments # before def func ( a , b = 1 ): return argname ( a ) func ( x ) # 'x' func ( x , b = 2 ) # error since 2 is not ast.Name # after def func ( a , b = 1 ): return argname ( a , pos_only = True ) func ( x ) # 'x' func ( x , b = 2 ) # 'x' Parse the arguments only if needed # before def func ( a , b ): return argname ( a ) func ( x , 1 ) # NonVariableArgumentError # after func ( x , 1 ) # 'x' Allow variable positional arguments for argname so that argname(*args) is allowed # before def func ( arg , * args ): return argname ( arg , args ) # *args not allowed x = y = 1 func ( x , y ) # ('x', ('y', 1)) # after def func ( arg , * args ): return argname ( arg , * args ) x = y = 1 func ( x , y ) # ('x', 'y') Add vars_only (defaults to False ) argument to helpers.debug so source of expression becomes available a = 1 debug ( a + a ) # DEBUG: a+a=2 v0.6.1 Add argname to retrieve argument names/sources passed to a function v0.6.0 Changed: Wrapper , register and debug moved to varname.helpers Argument caller changed to frame across all APIs ignore accepting module, filename, function, (function, num_decorators), (module, qualname) and (filename, qualname) Removed: inject (Use helpers.regiester instead) inject_varname (Use helpers.regiester instead) namedtuple Added: Arguments frame and ignore to Wrapper helpers.register as a decorator for functions v0.5.6 Add ignore argument to varname to ignore frames that are not counted by caller Deprecate inject_varname , use register instead v0.5.5 Deprecate inject and use inject_varname decorator instead v0.5.4 Allow varname.varname to receive multiple variables on the left-hand side v0.5.3 Add debug function Deprecate namedtuple (will be removed in 0.6.0 ) v0.5.2 Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked. v0.5.1 Add better messaging for weird nameof calls v0.5.0 Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available. v0.4.0 Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning . v0.3.0 Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14) v0.2.0 Fix #5 and fit nameof in more cases v0.1.7 Add inject function v0.1.6 Fit situations when frames cannot be fetched Add shortcut for namedtuple v0.1.5 Fix will from a property call v0.1.4 Add will to detect next immediate attribute name v0.1.3 Add arugment raise_exc for varname to raise an exception instead of returning var_<index> v0.1.2 Add function nameof v0.1.1 Add a value wrapper Wrapper class v0.1.0 Implement varname function","title":"Change Log"},{"location":"CHANGELOG/#v081","text":"Handle inspect raises \"could not get source code\" when printing rich exception message","title":"v0.8.1"},{"location":"CHANGELOG/#v080","text":"Compared to v0.7.3 - Add UsingExecWarning when exec is used to retrieve func for argname() . - Remove NonVariableArgumentError . Use ImproperUseError instead. - Add VarnameError and VarnameWarning as root for varname-related exceptions and warnings, respectively. - Default strict to True for varname() , helpers.register() and helpers.Wrapper() - Limit number of context lines for showing where ImproperUseError happens Compared to v0.7.0 - Add UsingExecWarning when exec is used to retrieve func for argname() . - Remove NonVariableArgumentError . Use ImproperUseError instead. - Add VarnameError and VarnameWarning as root for varname-related exceptions and warnings, respectively. - Add strict mode to varname() , helpers.register() and helpers.Wrapper() (#57) - Support the walrus operator ( := ) (#58) - Change argname() to accept argument names instead of arguments themselves - Remove pos_only argument from argname() - Add ignore argument to argname() to ignore intermediate frames - Limit VarnameRetrievingError to the situations only when the AST node is not able to be retrieved.","title":"v0.8.0"},{"location":"CHANGELOG/#v073","text":"Indicate where the ImproperUseError happens for varname() (Close #60) Add VarnameException and VarnameWarning as root for all varname-defined exceptions and warnings.","title":"v0.7.3"},{"location":"CHANGELOG/#v072","text":"Add strict mode to varname() (#57) Support the walrus operator ( := ) (#58)","title":"v0.7.2"},{"location":"CHANGELOG/#v071","text":"Add ignore argument to argname2() Fix Fix utils.get_argument_sources() when kwargs is given as **kwargs .","title":"v0.7.1"},{"location":"CHANGELOG/#v070","text":"ImproperUseError is now independent of VarnameRetrievingError Deprecate argname , superseded by argname2 >>> argname ( a , b , ... ) # before >>> argname2 ( 'a' , 'b' , ... ) # after Add dispatch argument to argname / argment2 to be used for single-dispatched functions.","title":"v0.7.0"},{"location":"CHANGELOG/#v065","text":"Add sep argument to helpers.debug()","title":"v0.6.5"},{"location":"CHANGELOG/#v064","text":"Add ImproperUseError to distinguish node retrieving error from improper varname use #49","title":"v0.6.4"},{"location":"CHANGELOG/#v063","text":"Fix standard library ignoring ignores 3rd-party libraries under site-packages/ Allow pathlib.Path object to be used in ignore items","title":"v0.6.3"},{"location":"CHANGELOG/#v062","text":"Remove argument full for nameof , use vars_only instead. When vars_only=False , source of the argument returned. # before: nameof ( a . b , full = True ) # 'a.b' nameof ( x [ 0 ], full = True ) # unable to fetch # after (requires asttoken): nameof ( a . b , vars_only = False ) # 'a.b' nameof ( x [ 0 ], vars_only = False ) # 'x[0]' Add argument frame to argname , so that it can be wrapped. def argname2 ( arg , * more_args ): return argname ( arg , * more_args , frame = 2 ) Allow argname to fetch the source of variable keyword arguments ( **kwargs ), which will be an empty dict ( {} ) when no keyword arguments passed. def func ( a , ** kwargs ): return argname ( a , kwargs ) # before: func ( x ) # raises error # after: func ( x ) # returns ('x', {}) Add argument pos_only to argname to only match the positional arguments # before def func ( a , b = 1 ): return argname ( a ) func ( x ) # 'x' func ( x , b = 2 ) # error since 2 is not ast.Name # after def func ( a , b = 1 ): return argname ( a , pos_only = True ) func ( x ) # 'x' func ( x , b = 2 ) # 'x' Parse the arguments only if needed # before def func ( a , b ): return argname ( a ) func ( x , 1 ) # NonVariableArgumentError # after func ( x , 1 ) # 'x' Allow variable positional arguments for argname so that argname(*args) is allowed # before def func ( arg , * args ): return argname ( arg , args ) # *args not allowed x = y = 1 func ( x , y ) # ('x', ('y', 1)) # after def func ( arg , * args ): return argname ( arg , * args ) x = y = 1 func ( x , y ) # ('x', 'y') Add vars_only (defaults to False ) argument to helpers.debug so source of expression becomes available a = 1 debug ( a + a ) # DEBUG: a+a=2","title":"v0.6.2"},{"location":"CHANGELOG/#v061","text":"Add argname to retrieve argument names/sources passed to a function","title":"v0.6.1"},{"location":"CHANGELOG/#v060","text":"Changed: Wrapper , register and debug moved to varname.helpers Argument caller changed to frame across all APIs ignore accepting module, filename, function, (function, num_decorators), (module, qualname) and (filename, qualname) Removed: inject (Use helpers.regiester instead) inject_varname (Use helpers.regiester instead) namedtuple Added: Arguments frame and ignore to Wrapper helpers.register as a decorator for functions","title":"v0.6.0"},{"location":"CHANGELOG/#v056","text":"Add ignore argument to varname to ignore frames that are not counted by caller Deprecate inject_varname , use register instead","title":"v0.5.6"},{"location":"CHANGELOG/#v055","text":"Deprecate inject and use inject_varname decorator instead","title":"v0.5.5"},{"location":"CHANGELOG/#v054","text":"Allow varname.varname to receive multiple variables on the left-hand side","title":"v0.5.4"},{"location":"CHANGELOG/#v053","text":"Add debug function Deprecate namedtuple (will be removed in 0.6.0 )","title":"v0.5.3"},{"location":"CHANGELOG/#v052","text":"Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked.","title":"v0.5.2"},{"location":"CHANGELOG/#v051","text":"Add better messaging for weird nameof calls","title":"v0.5.1"},{"location":"CHANGELOG/#v050","text":"Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available.","title":"v0.5.0"},{"location":"CHANGELOG/#v040","text":"Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning .","title":"v0.4.0"},{"location":"CHANGELOG/#v030","text":"Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14)","title":"v0.3.0"},{"location":"CHANGELOG/#v020","text":"Fix #5 and fit nameof in more cases","title":"v0.2.0"},{"location":"CHANGELOG/#v017","text":"Add inject function","title":"v0.1.7"},{"location":"CHANGELOG/#v016","text":"Fit situations when frames cannot be fetched Add shortcut for namedtuple","title":"v0.1.6"},{"location":"CHANGELOG/#v015","text":"Fix will from a property call","title":"v0.1.5"},{"location":"CHANGELOG/#v014","text":"Add will to detect next immediate attribute name","title":"v0.1.4"},{"location":"CHANGELOG/#v013","text":"Add arugment raise_exc for varname to raise an exception instead of returning var_<index>","title":"v0.1.3"},{"location":"CHANGELOG/#v012","text":"Add function nameof","title":"v0.1.2"},{"location":"CHANGELOG/#v011","text":"Add a value wrapper Wrapper class","title":"v0.1.1"},{"location":"CHANGELOG/#v010","text":"Implement varname function","title":"v0.1.0"},{"location":"api/varname.core/","text":"module varname . core </> Provide core features for varname Functions argname ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Get the names/sources of arguments passed to a function. </> argname2 ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Alias of argname, will be removed in v0.9.0 </> nameof ( var , *more_vars , frame , vars_only ) (Union(str, (str, ...))) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc , strict ) (Union(str, (str or tuple, ...))) \u2014 Get the name of the variable(s) that assigned by function call orclass instantiation. </> will ( frame , raise_exc ) (str) \u2014 Detect the attribute name right immediately after a function call. </> function varname.core . varname ( frame=1 , ignore=None , multi_vars=False , raise_exc=True , strict=True ) </> Get the name of the variable(s) that assigned by function call orclass instantiation. To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> from varname import config >>> config . debug = True Parameters frame (int, optional) \u2014 N th frame used to retrieve the variable name. This means N-1 intermediate frames will be skipped. Note that the frames match ignore will not be counted. See ignore for details. ignore (Union(module, str, path, function, (module or str, str), (function, int), list of union(module, str, path, function, (module or str, str), (function, int))), optional) \u2014 Frames to be ignored in order to reach the N th frame.These frames will not be counted to skip within that N-1 frames. You can specify: - A module (or filename of a module). Any calls from it and its submodules will be ignored. - A function. If it looks like it might be a decorated function, a MaybeDecoratedFunctionWarning will be shown. - Tuple of a function and a number of additional frames that should be skipped just before reaching this function in the stack. This is typically used for functions that have been decorated with a 'classic' decorator that replaces the function with a wrapper. In that case each such decorator involved should be counted in the number that's the second element of the tuple. - Tuple of a module (or filename) and qualified name (qualname). You can use Unix shell-style wildcards to match the qualname. Otherwise the qualname must appear exactly once in the module/file. By default, all calls from varname package, python standardlibraries and lambda functions are ignored. multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS).If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a ImproperUseError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failedto retrieve the ast node. Note that set this to False will NOT supress the exception when the use of varname is improper (i.e. multiple variables on LHS with multi_vars is False ). See Raises/ImproperUseError . strict (bool, optional) \u2014 Whether to only return the variable name(s) if the result ofthe call is assigned to it/them directly. Returns (Union(str, (str or tuple, ...))) The variable name, or None when raise_exc is False and we failed to retrieve the ast node for the variable(s). A tuple or a hierarchy (tuple of tuples) of variable names when multi_vars is True . Raises ImproperUseError \u2014 When the use of varname() is improper, including: - When LHS is not an ast.Name or ast.Attribute node or not a list/tuple of them - When there are multiple variables on LHS but multi_vars is False - When strict is True, but the result is not assigned to variable(s) directly Note that raise_exc=False will NOT suppress this exception. MultiTargetAssignmentWarning \u2014 When there are multiple targetin the assign node. (e.g: a = b = func() , in such a case, a == 'b' , may not be the case you want) VarnameRetrievingError \u2014 When we are unable to retrieve the ast nodefor the variable(s) and raise_exc is set to True . function varname.core . will ( frame=1 , raise_exc=True ) </> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters frame (int, optional) \u2014 At which frame this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect the ast nodeThis will NOT supress the ImproperUseError Returns (str) The attribute name right after the function call. None if ast node cannot be retrieved and raise_exc is False Raises ImproperUseError \u2014 When (the wraper of) this function is not calledinside a method/property of a class instance. Note that this exception will not be suppressed by raise_exc=False VarnameRetrievingError \u2014 When raise_exc is True and we failed todetect the attribute name (including not having one) function varname.core . nameof ( var , *more_vars , frame=1 , vars_only=True ) </> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of frame (int, optional) \u2014 The this function is called from the wrapper of it. frame=1 means no wrappers. Note that the calls from standard libraries are ignored. Also note that the wrapper has to have signature as this one. vars_only (bool, optional) \u2014 Whether only allow variables/attributes as arguments orany expressions. If True , then the sources of the arguments will be returned. Returns (Union(str, (str, ...))) The names/sources of variables/expressions passed in. If a single argument is passed, return the name/source of it. If multiple variables are passed, return a tuple of their names/sources. If the argument is an attribute (e.g. a.b ) and vars_only is False , only \"b\" will returned. Set vars_only to True to get \"a.b\" . Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved ortrying to retrieve the full name of non attribute series calls. function varname.core . argname ( arg , *more_args , func=None , dispatch=None , frame=1 , ignore=None , vars_only=True ) </> Get the names/sources of arguments passed to a function. Instead of passing the argument variables themselves to this function (like argname() does), you should pass their names instead. Parameters arg (str) \u2014 and *more_args (str) \u2014 The names of the arguments that you want to retrievenames/sources of. You can also use subscripts to get parts of the results. def func( args, *kwargs): return argname2('args[0]', 'kwargs[x]') # no quote needed Star argument is also allowed: def func( args, x = 1): return argname2(' args', 'x') a = b = c = 1 func(a, b, x=c) # ('a', 'b', 'c') Note the difference: def func(*args, x = 1): return argname2('args', 'x') a = b = c = 1 func(a, b, x=c) # (('a', 'b'), 'c') func (callable, optional) \u2014 The target function. If not provided, the AST node of thefunction call will be used to fetch the function: - If a variable (ast.Name) used as function, the node.id will be used to get the function from locals() or globals() . - If variable (ast.Name), attributes (ast.Attribute), subscripts (ast.Subscript), and combinations of those and literals used as function, pure_eval will be used to evaluate the node - If pure_eval is not installed or failed to evaluate, eval will be used. A warning will be shown since unwanted side effects may happen in this case. You are very encouraged to always pass the function explicitly. dispatch (type, optional) \u2014 If a function is a single-dispatched function, you canspecify a type for it to dispatch the real function. If this is specified, expect func to be the generic function if provided. frame (int, optional) \u2014 The frame where target function is called from this call.Calls from python standard libraries are ignored. ignore (Union(module, str, path, function, (module or str, str), (function, int), list of union(module, str, path, function, (module or str, str), (function, int))), optional) \u2014 The intermediate calls to be ignored. See varname.ignore vars_only (bool, optional) \u2014 Require the arguments to be variables only.If False, asttokens is required to retrieve the source. Returns (Union(ast, str, (ast or str, ...), )) The argument source when no more_args passed, otherwise a tuple ofargument sources Raises VarnameRetrievingError \u2014 When the ast node where the function is calledcannot be retrieved function varname.core . argname2 ( arg , *more_args , func=None , dispatch=None , frame=1 , ignore=None , vars_only=True ) \u2192 Union(ast, str, (ast or str, ...), ) </> Alias of argname, will be removed in v0.9.0","title":"varname.core"},{"location":"api/varname.core/#varnamecore","text":"</> Provide core features for varname Functions argname ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Get the names/sources of arguments passed to a function. </> argname2 ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Alias of argname, will be removed in v0.9.0 </> nameof ( var , *more_vars , frame , vars_only ) (Union(str, (str, ...))) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc , strict ) (Union(str, (str or tuple, ...))) \u2014 Get the name of the variable(s) that assigned by function call orclass instantiation. </> will ( frame , raise_exc ) (str) \u2014 Detect the attribute name right immediately after a function call. </> function","title":"varname.core"},{"location":"api/varname.core/#varnamecorevarname","text":"</> Get the name of the variable(s) that assigned by function call orclass instantiation. To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> from varname import config >>> config . debug = True Parameters frame (int, optional) \u2014 N th frame used to retrieve the variable name. This means N-1 intermediate frames will be skipped. Note that the frames match ignore will not be counted. See ignore for details. ignore (Union(module, str, path, function, (module or str, str), (function, int), list of union(module, str, path, function, (module or str, str), (function, int))), optional) \u2014 Frames to be ignored in order to reach the N th frame.These frames will not be counted to skip within that N-1 frames. You can specify: - A module (or filename of a module). Any calls from it and its submodules will be ignored. - A function. If it looks like it might be a decorated function, a MaybeDecoratedFunctionWarning will be shown. - Tuple of a function and a number of additional frames that should be skipped just before reaching this function in the stack. This is typically used for functions that have been decorated with a 'classic' decorator that replaces the function with a wrapper. In that case each such decorator involved should be counted in the number that's the second element of the tuple. - Tuple of a module (or filename) and qualified name (qualname). You can use Unix shell-style wildcards to match the qualname. Otherwise the qualname must appear exactly once in the module/file. By default, all calls from varname package, python standardlibraries and lambda functions are ignored. multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS).If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a ImproperUseError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failedto retrieve the ast node. Note that set this to False will NOT supress the exception when the use of varname is improper (i.e. multiple variables on LHS with multi_vars is False ). See Raises/ImproperUseError . strict (bool, optional) \u2014 Whether to only return the variable name(s) if the result ofthe call is assigned to it/them directly. Returns (Union(str, (str or tuple, ...))) The variable name, or None when raise_exc is False and we failed to retrieve the ast node for the variable(s). A tuple or a hierarchy (tuple of tuples) of variable names when multi_vars is True . Raises ImproperUseError \u2014 When the use of varname() is improper, including: - When LHS is not an ast.Name or ast.Attribute node or not a list/tuple of them - When there are multiple variables on LHS but multi_vars is False - When strict is True, but the result is not assigned to variable(s) directly Note that raise_exc=False will NOT suppress this exception. MultiTargetAssignmentWarning \u2014 When there are multiple targetin the assign node. (e.g: a = b = func() , in such a case, a == 'b' , may not be the case you want) VarnameRetrievingError \u2014 When we are unable to retrieve the ast nodefor the variable(s) and raise_exc is set to True . function","title":"varname.core.varname"},{"location":"api/varname.core/#varnamecorewill","text":"</> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters frame (int, optional) \u2014 At which frame this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect the ast nodeThis will NOT supress the ImproperUseError Returns (str) The attribute name right after the function call. None if ast node cannot be retrieved and raise_exc is False Raises ImproperUseError \u2014 When (the wraper of) this function is not calledinside a method/property of a class instance. Note that this exception will not be suppressed by raise_exc=False VarnameRetrievingError \u2014 When raise_exc is True and we failed todetect the attribute name (including not having one) function","title":"varname.core.will"},{"location":"api/varname.core/#varnamecorenameof","text":"</> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of frame (int, optional) \u2014 The this function is called from the wrapper of it. frame=1 means no wrappers. Note that the calls from standard libraries are ignored. Also note that the wrapper has to have signature as this one. vars_only (bool, optional) \u2014 Whether only allow variables/attributes as arguments orany expressions. If True , then the sources of the arguments will be returned. Returns (Union(str, (str, ...))) The names/sources of variables/expressions passed in. If a single argument is passed, return the name/source of it. If multiple variables are passed, return a tuple of their names/sources. If the argument is an attribute (e.g. a.b ) and vars_only is False , only \"b\" will returned. Set vars_only to True to get \"a.b\" . Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved ortrying to retrieve the full name of non attribute series calls. function","title":"varname.core.nameof"},{"location":"api/varname.core/#varnamecoreargname","text":"</> Get the names/sources of arguments passed to a function. Instead of passing the argument variables themselves to this function (like argname() does), you should pass their names instead. Parameters arg (str) \u2014 and *more_args (str) \u2014 The names of the arguments that you want to retrievenames/sources of. You can also use subscripts to get parts of the results. def func( args, *kwargs): return argname2('args[0]', 'kwargs[x]') # no quote needed Star argument is also allowed: def func( args, x = 1): return argname2(' args', 'x') a = b = c = 1 func(a, b, x=c) # ('a', 'b', 'c') Note the difference: def func(*args, x = 1): return argname2('args', 'x') a = b = c = 1 func(a, b, x=c) # (('a', 'b'), 'c') func (callable, optional) \u2014 The target function. If not provided, the AST node of thefunction call will be used to fetch the function: - If a variable (ast.Name) used as function, the node.id will be used to get the function from locals() or globals() . - If variable (ast.Name), attributes (ast.Attribute), subscripts (ast.Subscript), and combinations of those and literals used as function, pure_eval will be used to evaluate the node - If pure_eval is not installed or failed to evaluate, eval will be used. A warning will be shown since unwanted side effects may happen in this case. You are very encouraged to always pass the function explicitly. dispatch (type, optional) \u2014 If a function is a single-dispatched function, you canspecify a type for it to dispatch the real function. If this is specified, expect func to be the generic function if provided. frame (int, optional) \u2014 The frame where target function is called from this call.Calls from python standard libraries are ignored. ignore (Union(module, str, path, function, (module or str, str), (function, int), list of union(module, str, path, function, (module or str, str), (function, int))), optional) \u2014 The intermediate calls to be ignored. See varname.ignore vars_only (bool, optional) \u2014 Require the arguments to be variables only.If False, asttokens is required to retrieve the source. Returns (Union(ast, str, (ast or str, ...), )) The argument source when no more_args passed, otherwise a tuple ofargument sources Raises VarnameRetrievingError \u2014 When the ast node where the function is calledcannot be retrieved function","title":"varname.core.argname"},{"location":"api/varname.core/#varnamecoreargname2","text":"</> Alias of argname, will be removed in v0.9.0","title":"varname.core.argname2"},{"location":"api/varname.helpers/","text":"module varname . helpers </> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr , sep , vars_only ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc , strict ) (type or callable) \u2014 A decorator to register varname to a class or function </> function varname.helpers . register ( cls_or_func=None , frame=1 , ignore=None , multi_vars=False , raise_exc=True , strict=True ) </> A decorator to register varname to a class or function When registered to a class, it can be accessed by self.__varname__ ; while to a function, it is registered to globals, meaning that it can be accessed directly. Parameters frame (int, optional) \u2014 The call stack index, indicating where this classis instantiated relative to where the variable is finally retrieved multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS).If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failedto retrieve the name. strict (bool, optional) \u2014 Whether to only return the variable name if the result ofthe call is assigned to it directly. Examples >>> @varname . register >>> class Foo : pass >>> foo = Foo () >>> # foo.__varname__ == 'foo' >>> >>> @varname . register >>> def func (): >>> return __varname__ >>> foo = func () # foo == 'foo' Returns (type or callable) The wrapper function or the class/function itselfif it is specified explictly. class varname.helpers . Wrapper ( value , frame=1 , ignore=None , raise_exc=True , strict=True ) </> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve strict (bool, optional) \u2014 Whether to only return the variable name if the wrapper isassigned to it directly. Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps function varname.helpers . debug ( var , *more_vars , prefix='DEBUG: ' , merge=False , repr=True , sep='=' , vars_only=False ) </> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var) sep (str, optional) \u2014 The separator between the variable name and value","title":"varname.helpers"},{"location":"api/varname.helpers/#varnamehelpers","text":"</> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr , sep , vars_only ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc , strict ) (type or callable) \u2014 A decorator to register varname to a class or function </> function","title":"varname.helpers"},{"location":"api/varname.helpers/#varnamehelpersregister","text":"</> A decorator to register varname to a class or function When registered to a class, it can be accessed by self.__varname__ ; while to a function, it is registered to globals, meaning that it can be accessed directly. Parameters frame (int, optional) \u2014 The call stack index, indicating where this classis instantiated relative to where the variable is finally retrieved multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS).If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failedto retrieve the name. strict (bool, optional) \u2014 Whether to only return the variable name if the result ofthe call is assigned to it directly. Examples >>> @varname . register >>> class Foo : pass >>> foo = Foo () >>> # foo.__varname__ == 'foo' >>> >>> @varname . register >>> def func (): >>> return __varname__ >>> foo = func () # foo == 'foo' Returns (type or callable) The wrapper function or the class/function itselfif it is specified explictly. class","title":"varname.helpers.register"},{"location":"api/varname.helpers/#varnamehelperswrapper","text":"</> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve strict (bool, optional) \u2014 Whether to only return the variable name if the wrapper isassigned to it directly. Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps function","title":"varname.helpers.Wrapper"},{"location":"api/varname.helpers/#varnamehelpersdebug","text":"</> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var) sep (str, optional) \u2014 The separator between the variable name and value","title":"varname.helpers.debug"},{"location":"api/varname.ignore/","text":"module varname . ignore </> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreStdlib \u2014 Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> abstract class varname.ignore . IgnoreElem ( ) </> An element of the ignore list Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses abstract method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element method __repr__ ( ) \u2192 str </> Representation of the element class varname.ignore . IgnoreModule ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls from a module or its submodules Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreFilename ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls from a module by matching its filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreDirname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls from modules inside a directory Currently used internally to ignore calls from standard libraries. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreStdlib ( *ign_args ) </> Bases varname.ignore.IgnoreDirname varname.ignore.IgnoreElem Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) But we need to ignore 3rd-party packages under site-packages/. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreFunction ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore a non-decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreDecorated ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore a decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreModuleQualname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls by qualified name in the module Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreFilenameQualname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls with given qualname in the module with the filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreOnlyQualname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls that match the given qualname, across all frames. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element function varname.ignore . create_ignore_elem ( ignore_elem ) \u2192 IgnoreElem </> Create an ignore element according to the type class varname.ignore . IgnoreList ( ignore_list ) </> The ignore list to match the frames to see if they should be ignored Methods create ( ignore , ignore_lambda , ignore_varname ) ( IgnoreList ) \u2014 Create an IgnoreList object </> get_frame ( frame_no ) (frame) \u2014 Get the right frame by the frame number </> nextframe_to_check ( frame_no , frameinfos ) (int) \u2014 Find the next frame to check </> classmethod create ( ignore=None , ignore_lambda=True , ignore_varname=True ) </> Create an IgnoreList object Parameters ignore (Union(module, str, path, function, (module or str, str), (function, int), list of union(module, str, path, function, (module or str, str), (function, int))), optional) \u2014 An element of the ignore list, eitherA module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators ignore_lambda (bool, optional) \u2014 whether ignore lambda functions ignore_varname (bool, optional) \u2014 whether the calls from this package Returns ( IgnoreList ) The IgnoreList object method nextframe_to_check ( frame_no , frameinfos ) </> Find the next frame to check In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next ignore[1] th frame. Parameters frame_no (int) \u2014 The index of current frame to check frameinfos (list of FrameInfo) \u2014 The frame info objects Returns (int) A number for Next N th frame to check. 0 if no frame matched. method get_frame ( frame_no ) </> Get the right frame by the frame number Parameters frame_no (int) \u2014 The index of the frame to get Returns (frame) The desired frame Raises VarnameRetrievingError \u2014 if any exceptions raised during the process.","title":"varname.ignore"},{"location":"api/varname.ignore/#varnameignore","text":"</> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreStdlib \u2014 Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> abstract class","title":"varname.ignore"},{"location":"api/varname.ignore/#varnameignoreignoreelem","text":"</> An element of the ignore list Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> classmethod","title":"varname.ignore.IgnoreElem"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass","text":"</> Define different attributes for subclasses abstract method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreelemmatch","text":"</> Whether the frame matches the ignore element method","title":"varname.ignore.IgnoreElem.match"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr","text":"</> Representation of the element class","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoremodule","text":"</> Bases varname.ignore.IgnoreElem Ignore calls from a module or its submodules Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreModule"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_1","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_1","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoremodulematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreModule.match"},{"location":"api/varname.ignore/#varnameignoreignorefilename","text":"</> Bases varname.ignore.IgnoreElem Ignore calls from a module by matching its filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreFilename"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_2","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_1","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_2","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorefilenamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreFilename.match"},{"location":"api/varname.ignore/#varnameignoreignoredirname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls from modules inside a directory Currently used internally to ignore calls from standard libraries. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreDirname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_3","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_2","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_3","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoredirnamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreDirname.match"},{"location":"api/varname.ignore/#varnameignoreignorestdlib","text":"</> Bases varname.ignore.IgnoreDirname varname.ignore.IgnoreElem Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) But we need to ignore 3rd-party packages under site-packages/. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreStdlib"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_4","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_3","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_4","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorestdlibmatch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreStdlib.match"},{"location":"api/varname.ignore/#varnameignoreignorefunction","text":"</> Bases varname.ignore.IgnoreElem Ignore a non-decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreFunction"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_5","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_4","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_5","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorefunctionmatch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreFunction.match"},{"location":"api/varname.ignore/#varnameignoreignoredecorated","text":"</> Bases varname.ignore.IgnoreElem Ignore a decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreDecorated"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_6","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_5","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_6","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoredecoratedmatch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreDecorated.match"},{"location":"api/varname.ignore/#varnameignoreignoremodulequalname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls by qualified name in the module Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreModuleQualname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_7","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_6","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_7","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoremodulequalnamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreModuleQualname.match"},{"location":"api/varname.ignore/#varnameignoreignorefilenamequalname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls with given qualname in the module with the filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreFilenameQualname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_8","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_7","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_8","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorefilenamequalnamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreFilenameQualname.match"},{"location":"api/varname.ignore/#varnameignoreignoreonlyqualname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls that match the given qualname, across all frames. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreOnlyQualname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_9","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_8","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_9","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoreonlyqualnamematch","text":"</> Whether the frame matches the ignore element function","title":"varname.ignore.IgnoreOnlyQualname.match"},{"location":"api/varname.ignore/#varnameignorecreate_ignore_elem","text":"</> Create an ignore element according to the type class","title":"varname.ignore.create_ignore_elem"},{"location":"api/varname.ignore/#varnameignoreignorelist","text":"</> The ignore list to match the frames to see if they should be ignored Methods create ( ignore , ignore_lambda , ignore_varname ) ( IgnoreList ) \u2014 Create an IgnoreList object </> get_frame ( frame_no ) (frame) \u2014 Get the right frame by the frame number </> nextframe_to_check ( frame_no , frameinfos ) (int) \u2014 Find the next frame to check </> classmethod","title":"varname.ignore.IgnoreList"},{"location":"api/varname.ignore/#varnameignoreignorelistcreate","text":"</> Create an IgnoreList object Parameters ignore (Union(module, str, path, function, (module or str, str), (function, int), list of union(module, str, path, function, (module or str, str), (function, int))), optional) \u2014 An element of the ignore list, eitherA module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators ignore_lambda (bool, optional) \u2014 whether ignore lambda functions ignore_varname (bool, optional) \u2014 whether the calls from this package Returns ( IgnoreList ) The IgnoreList object method","title":"varname.ignore.IgnoreList.create"},{"location":"api/varname.ignore/#varnameignoreignorelistnextframe_to_check","text":"</> Find the next frame to check In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next ignore[1] th frame. Parameters frame_no (int) \u2014 The index of current frame to check frameinfos (list of FrameInfo) \u2014 The frame info objects Returns (int) A number for Next N th frame to check. 0 if no frame matched. method","title":"varname.ignore.IgnoreList.nextframe_to_check"},{"location":"api/varname.ignore/#varnameignoreignorelistget_frame","text":"</> Get the right frame by the frame number Parameters frame_no (int) \u2014 The index of the frame to get Returns (frame) The desired frame Raises VarnameRetrievingError \u2014 if any exceptions raised during the process.","title":"varname.ignore.IgnoreList.get_frame"},{"location":"api/varname/","text":"package varname </> Dark magics about variable names in python module varname . core </> Provide core features for varname Functions argname ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Get the names/sources of arguments passed to a function. </> argname2 ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Alias of argname, will be removed in v0.9.0 </> nameof ( var , *more_vars , frame , vars_only ) (Union(str, (str, ...))) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc , strict ) (Union(str, (str or tuple, ...))) \u2014 Get the name of the variable(s) that assigned by function call orclass instantiation. </> will ( frame , raise_exc ) (str) \u2014 Detect the attribute name right immediately after a function call. </> module varname . helpers </> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr , sep , vars_only ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc , strict ) (type or callable) \u2014 A decorator to register varname to a class or function </> module varname . ignore </> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreStdlib \u2014 Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> module varname . utils </> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameException \u2014 Root exception for all varname exceptions </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references tomultiple objects in a module </> ImproperUseError \u2014 When varname() is improperly used </> VarnameWarning \u2014 Root warning for all varname warnings </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name ina multi-target assignment </> UsingExecWarning \u2014 When exec is used to retrieve function name for argname() </> Functions argnode_source ( source , node , vars_only ) (str or AST) \u2014 Get the source of an argument node </> attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( code , offset ) (str) \u2014 Cached Bytecode version of nameof </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_argument_sources ( source , node , func , vars_only ) \u2014 Get the sources for argument from an ast.Call node </> get_function_called_argname ( frame , node ) (callable) \u2014 Get the function who called argname </> get_node ( frame , ignore , raise_exc , ignore_lambda ) (AST) \u2014 Try to get node from the executing object. </> get_node_by_frame ( frame , raise_exc ) (AST) \u2014 Get the node by frame, raise errors if possible </> lookfor_parent_assign ( node , strict ) (Assign, AnnAssign, or NamedExpr) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple, ...))) \u2014 Get the node node name. </> rich_exc_message ( msg , node , context_lines ) (str) \u2014 Attach the source code from the node to message toget a rich message for exceptions </>","title":"API"},{"location":"api/varname/#varname","text":"</> Dark magics about variable names in python module","title":"varname"},{"location":"api/varname/#varnamecore","text":"</> Provide core features for varname Functions argname ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Get the names/sources of arguments passed to a function. </> argname2 ( arg , *more_args , func , dispatch , frame , ignore , vars_only ) (Union(ast, str, (ast or str, ...), )) \u2014 Alias of argname, will be removed in v0.9.0 </> nameof ( var , *more_vars , frame , vars_only ) (Union(str, (str, ...))) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc , strict ) (Union(str, (str or tuple, ...))) \u2014 Get the name of the variable(s) that assigned by function call orclass instantiation. </> will ( frame , raise_exc ) (str) \u2014 Detect the attribute name right immediately after a function call. </> module","title":"varname.core"},{"location":"api/varname/#varnamehelpers","text":"</> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr , sep , vars_only ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc , strict ) (type or callable) \u2014 A decorator to register varname to a class or function </> module","title":"varname.helpers"},{"location":"api/varname/#varnameignore","text":"</> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreStdlib \u2014 Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> module","title":"varname.ignore"},{"location":"api/varname/#varnameutils","text":"</> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameException \u2014 Root exception for all varname exceptions </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references tomultiple objects in a module </> ImproperUseError \u2014 When varname() is improperly used </> VarnameWarning \u2014 Root warning for all varname warnings </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name ina multi-target assignment </> UsingExecWarning \u2014 When exec is used to retrieve function name for argname() </> Functions argnode_source ( source , node , vars_only ) (str or AST) \u2014 Get the source of an argument node </> attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( code , offset ) (str) \u2014 Cached Bytecode version of nameof </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_argument_sources ( source , node , func , vars_only ) \u2014 Get the sources for argument from an ast.Call node </> get_function_called_argname ( frame , node ) (callable) \u2014 Get the function who called argname </> get_node ( frame , ignore , raise_exc , ignore_lambda ) (AST) \u2014 Try to get node from the executing object. </> get_node_by_frame ( frame , raise_exc ) (AST) \u2014 Get the node by frame, raise errors if possible </> lookfor_parent_assign ( node , strict ) (Assign, AnnAssign, or NamedExpr) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple, ...))) \u2014 Get the node node name. </> rich_exc_message ( msg , node , context_lines ) (str) \u2014 Attach the source code from the node to message toget a rich message for exceptions </>","title":"varname.utils"},{"location":"api/varname.utils/","text":"module varname . utils </> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameException \u2014 Root exception for all varname exceptions </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references tomultiple objects in a module </> ImproperUseError \u2014 When varname() is improperly used </> VarnameWarning \u2014 Root warning for all varname warnings </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name ina multi-target assignment </> UsingExecWarning \u2014 When exec is used to retrieve function name for argname() </> Functions argnode_source ( source , node , vars_only ) (str or AST) \u2014 Get the source of an argument node </> attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( code , offset ) (str) \u2014 Cached Bytecode version of nameof </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_argument_sources ( source , node , func , vars_only ) \u2014 Get the sources for argument from an ast.Call node </> get_function_called_argname ( frame , node ) (callable) \u2014 Get the function who called argname </> get_node ( frame , ignore , raise_exc , ignore_lambda ) (AST) \u2014 Try to get node from the executing object. </> get_node_by_frame ( frame , raise_exc ) (AST) \u2014 Get the node by frame, raise errors if possible </> lookfor_parent_assign ( node , strict ) (Assign, AnnAssign, or NamedExpr) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple, ...))) \u2014 Get the node node name. </> rich_exc_message ( msg , node , context_lines ) (str) \u2014 Attach the source code from the node to message toget a rich message for exceptions </> class varname.utils . config ( ) </> Global configurations for varname Attributes debug \u2014 Show debug information for frames being ignored class varname.utils . VarnameException ( ) </> Bases Exception BaseException Root exception for all varname exceptions class varname.utils . VarnameRetrievingError ( ) </> Bases varname.utils.VarnameException Exception BaseException When failed to retrieve the varname class varname.utils . QualnameNonUniqueError ( ) </> Bases varname.utils.VarnameException Exception BaseException When a qualified name is used as an ignore element but references tomultiple objects in a module class varname.utils . ImproperUseError ( ) </> Bases varname.utils.VarnameException Exception BaseException When varname() is improperly used class varname.utils . VarnameWarning ( ) </> Bases Warning Exception BaseException Root warning for all varname warnings class varname.utils . MaybeDecoratedFunctionWarning ( ) </> Bases varname.utils.VarnameWarning Warning Exception BaseException When a suspecious decorated function used as ignore function directly class varname.utils . MultiTargetAssignmentWarning ( ) </> Bases varname.utils.VarnameWarning Warning Exception BaseException When varname tries to retrieve variable name ina multi-target assignment class varname.utils . UsingExecWarning ( ) </> Bases varname.utils.VarnameWarning Warning Exception BaseException When exec is used to retrieve function name for argname() function varname.utils . cached_getmodule ( codeobj ) </> Cached version of inspect.getmodule function varname.utils . get_node ( frame , ignore=None , raise_exc=True , ignore_lambda=True ) \u2192 AST </> Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge reticulate , where only first frame is kept. When the node can not be retrieved, try to return the first statement. function varname.utils . get_node_by_frame ( frame , raise_exc=True ) \u2192 AST </> Get the node by frame, raise errors if possible function varname.utils . lookfor_parent_assign ( node , strict=True ) \u2192 Assign, AnnAssign, or NamedExpr </> Look for an ast.Assign node in the parents function varname.utils . node_name ( node ) \u2192 Union(str, (str or tuple, ...)) </> Get the node node name. Raises ImproperUseError when failed function varname.utils . bytecode_nameof ( code , offset ) \u2192 str </> Cached Bytecode version of nameof We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with eval , or other circumstances where the code is manipulated to run but sourcecode is not available. function varname.utils . attach_ignore_id_to_module ( module ) </> Attach the ignore id to module This is useful when a module cannot be retrieved by frames using inspect.getmodule , then we can use this id, which will exist in frame.f_globals to check if the module matches in ignore. Do it only when the file is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and inspect.getmodule would not work function varname.utils . frame_matches_module_by_ignore_id ( frame , module ) \u2192 bool </> Check if the frame is from the module by ignore id function varname.utils . check_qualname_by_source ( source , modname , qualname ) </> Check if a qualname in module is unique function varname.utils . debug_ignore_frame ( msg , frameinfo=None ) </> Print the debug message for a given frame info object Parameters msg (str) \u2014 The debugging message frameinfo (FrameInfo, optional) \u2014 The FrameInfo object for the frame function varname.utils . argnode_source ( source , node , vars_only ) </> Get the source of an argument node Parameters source (Source) \u2014 The executing source object node (AST) \u2014 The node to get the source from vars_only (bool) \u2014 Whether only allow variables and attributes Returns (str or AST) The source of the node (node.id for ast.Name, node.attr for ast.Attribute). Or the node itself if the source cannot be fetched. function varname.utils . get_argument_sources ( source , node , func , vars_only ) </> Get the sources for argument from an ast.Call node >>> def func ( a , b , c , d = 4 ): >>> ... >>> x = y = z = 1 >>> func ( y , x , c = z ) >>> # argument_sources = {'a': 'y', 'b', 'x', 'c': 'z'} >>> func ( y , x , c = 1 ) >>> # argument_sources = {'a': 'y', 'b', 'x', 'c': ast.Num(n=1)} function varname.utils . get_function_called_argname ( frame , node ) \u2192 callable </> Get the function who called argname function varname.utils . rich_exc_message ( msg , node , context_lines=4 ) \u2192 str </> Attach the source code from the node to message toget a rich message for exceptions If package 'rich' is not install or 'node. frame ' doesn't exist, fall to plain message (with basic information), otherwise show a better message with full information","title":"varname.utils"},{"location":"api/varname.utils/#varnameutils","text":"</> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameException \u2014 Root exception for all varname exceptions </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references tomultiple objects in a module </> ImproperUseError \u2014 When varname() is improperly used </> VarnameWarning \u2014 Root warning for all varname warnings </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name ina multi-target assignment </> UsingExecWarning \u2014 When exec is used to retrieve function name for argname() </> Functions argnode_source ( source , node , vars_only ) (str or AST) \u2014 Get the source of an argument node </> attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( code , offset ) (str) \u2014 Cached Bytecode version of nameof </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_argument_sources ( source , node , func , vars_only ) \u2014 Get the sources for argument from an ast.Call node </> get_function_called_argname ( frame , node ) (callable) \u2014 Get the function who called argname </> get_node ( frame , ignore , raise_exc , ignore_lambda ) (AST) \u2014 Try to get node from the executing object. </> get_node_by_frame ( frame , raise_exc ) (AST) \u2014 Get the node by frame, raise errors if possible </> lookfor_parent_assign ( node , strict ) (Assign, AnnAssign, or NamedExpr) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple, ...))) \u2014 Get the node node name. </> rich_exc_message ( msg , node , context_lines ) (str) \u2014 Attach the source code from the node to message toget a rich message for exceptions </> class","title":"varname.utils"},{"location":"api/varname.utils/#varnameutilsconfig","text":"</> Global configurations for varname Attributes debug \u2014 Show debug information for frames being ignored class","title":"varname.utils.config"},{"location":"api/varname.utils/#varnameutilsvarnameexception","text":"</> Bases Exception BaseException Root exception for all varname exceptions class","title":"varname.utils.VarnameException"},{"location":"api/varname.utils/#varnameutilsvarnameretrievingerror","text":"</> Bases varname.utils.VarnameException Exception BaseException When failed to retrieve the varname class","title":"varname.utils.VarnameRetrievingError"},{"location":"api/varname.utils/#varnameutilsqualnamenonuniqueerror","text":"</> Bases varname.utils.VarnameException Exception BaseException When a qualified name is used as an ignore element but references tomultiple objects in a module class","title":"varname.utils.QualnameNonUniqueError"},{"location":"api/varname.utils/#varnameutilsimproperuseerror","text":"</> Bases varname.utils.VarnameException Exception BaseException When varname() is improperly used class","title":"varname.utils.ImproperUseError"},{"location":"api/varname.utils/#varnameutilsvarnamewarning","text":"</> Bases Warning Exception BaseException Root warning for all varname warnings class","title":"varname.utils.VarnameWarning"},{"location":"api/varname.utils/#varnameutilsmaybedecoratedfunctionwarning","text":"</> Bases varname.utils.VarnameWarning Warning Exception BaseException When a suspecious decorated function used as ignore function directly class","title":"varname.utils.MaybeDecoratedFunctionWarning"},{"location":"api/varname.utils/#varnameutilsmultitargetassignmentwarning","text":"</> Bases varname.utils.VarnameWarning Warning Exception BaseException When varname tries to retrieve variable name ina multi-target assignment class","title":"varname.utils.MultiTargetAssignmentWarning"},{"location":"api/varname.utils/#varnameutilsusingexecwarning","text":"</> Bases varname.utils.VarnameWarning Warning Exception BaseException When exec is used to retrieve function name for argname() function","title":"varname.utils.UsingExecWarning"},{"location":"api/varname.utils/#varnameutilscached_getmodule","text":"</> Cached version of inspect.getmodule function","title":"varname.utils.cached_getmodule"},{"location":"api/varname.utils/#varnameutilsget_node","text":"</> Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge reticulate , where only first frame is kept. When the node can not be retrieved, try to return the first statement. function","title":"varname.utils.get_node"},{"location":"api/varname.utils/#varnameutilsget_node_by_frame","text":"</> Get the node by frame, raise errors if possible function","title":"varname.utils.get_node_by_frame"},{"location":"api/varname.utils/#varnameutilslookfor_parent_assign","text":"</> Look for an ast.Assign node in the parents function","title":"varname.utils.lookfor_parent_assign"},{"location":"api/varname.utils/#varnameutilsnode_name","text":"</> Get the node node name. Raises ImproperUseError when failed function","title":"varname.utils.node_name"},{"location":"api/varname.utils/#varnameutilsbytecode_nameof","text":"</> Cached Bytecode version of nameof We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with eval , or other circumstances where the code is manipulated to run but sourcecode is not available. function","title":"varname.utils.bytecode_nameof"},{"location":"api/varname.utils/#varnameutilsattach_ignore_id_to_module","text":"</> Attach the ignore id to module This is useful when a module cannot be retrieved by frames using inspect.getmodule , then we can use this id, which will exist in frame.f_globals to check if the module matches in ignore. Do it only when the file is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and inspect.getmodule would not work function","title":"varname.utils.attach_ignore_id_to_module"},{"location":"api/varname.utils/#varnameutilsframe_matches_module_by_ignore_id","text":"</> Check if the frame is from the module by ignore id function","title":"varname.utils.frame_matches_module_by_ignore_id"},{"location":"api/varname.utils/#varnameutilscheck_qualname_by_source","text":"</> Check if a qualname in module is unique function","title":"varname.utils.check_qualname_by_source"},{"location":"api/varname.utils/#varnameutilsdebug_ignore_frame","text":"</> Print the debug message for a given frame info object Parameters msg (str) \u2014 The debugging message frameinfo (FrameInfo, optional) \u2014 The FrameInfo object for the frame function","title":"varname.utils.debug_ignore_frame"},{"location":"api/varname.utils/#varnameutilsargnode_source","text":"</> Get the source of an argument node Parameters source (Source) \u2014 The executing source object node (AST) \u2014 The node to get the source from vars_only (bool) \u2014 Whether only allow variables and attributes Returns (str or AST) The source of the node (node.id for ast.Name, node.attr for ast.Attribute). Or the node itself if the source cannot be fetched. function","title":"varname.utils.argnode_source"},{"location":"api/varname.utils/#varnameutilsget_argument_sources","text":"</> Get the sources for argument from an ast.Call node >>> def func ( a , b , c , d = 4 ): >>> ... >>> x = y = z = 1 >>> func ( y , x , c = z ) >>> # argument_sources = {'a': 'y', 'b', 'x', 'c': 'z'} >>> func ( y , x , c = 1 ) >>> # argument_sources = {'a': 'y', 'b', 'x', 'c': ast.Num(n=1)} function","title":"varname.utils.get_argument_sources"},{"location":"api/varname.utils/#varnameutilsget_function_called_argname","text":"</> Get the function who called argname function","title":"varname.utils.get_function_called_argname"},{"location":"api/varname.utils/#varnameutilsrich_exc_message","text":"</> Attach the source code from the node to message toget a rich message for exceptions If package 'rich' is not install or 'node. frame ' doesn't exist, fall to plain message (with basic information), otherwise show a better message with full information","title":"varname.utils.rich_exc_message"},{"location":"api/source/varname.core/","text":"SOURCE CODE varname. core DOCS \"\"\"Provide core features for varname\"\"\" import ast import re import warnings from typing import List , Tuple , Type , Union , Callable from executing import Source from .utils import ( bytecode_nameof , get_node , get_node_by_frame , lookfor_parent_assign , node_name , get_argument_sources , get_function_called_argname , rich_exc_message , ArgSourceType , VarnameRetrievingError , ImproperUseError , MultiTargetAssignmentWarning , ) from .ignore import IgnoreList , IgnoreType def varname ( DOCS frame : int = 1 , ignore : IgnoreType = None , multi_vars : bool = False , raise_exc : bool = True , strict : bool = True , ) -> Union [ str , Tuple [ Union [ str , Tuple ], ... ]]: \"\"\"Get the name of the variable(s) that assigned by function call or class instantiation. To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> from varname import config >>> config.debug = True Args: frame: `N`th frame used to retrieve the variable name. This means `N-1` intermediate frames will be skipped. Note that the frames match `ignore` will not be counted. See `ignore` for details. ignore: Frames to be ignored in order to reach the `N`th frame. These frames will not be counted to skip within that `N-1` frames. You can specify: - A module (or filename of a module). Any calls from it and its submodules will be ignored. - A function. If it looks like it might be a decorated function, a `MaybeDecoratedFunctionWarning` will be shown. - Tuple of a function and a number of additional frames that should be skipped just before reaching this function in the stack. This is typically used for functions that have been decorated with a 'classic' decorator that replaces the function with a wrapper. In that case each such decorator involved should be counted in the number that's the second element of the tuple. - Tuple of a module (or filename) and qualified name (qualname). You can use Unix shell-style wildcards to match the qualname. Otherwise the qualname must appear exactly once in the module/file. By default, all calls from `varname` package, python standard libraries and lambda functions are ignored. multi_vars: Whether allow multiple variables on left-hand side (LHS). If `True`, this function returns a tuple of the variable names, even there is only one variable on LHS. If `False`, and multiple variables on LHS, a `ImproperUseError` will be raised. raise_exc: Whether we should raise an exception if failed to retrieve the ast node. Note that set this to `False` will NOT supress the exception when the use of `varname` is improper (i.e. multiple variables on LHS with `multi_vars` is `False`). See `Raises/ImproperUseError`. strict: Whether to only return the variable name(s) if the result of the call is assigned to it/them directly. Returns: The variable name, or `None` when `raise_exc` is `False` and we failed to retrieve the ast node for the variable(s). A tuple or a hierarchy (tuple of tuples) of variable names when `multi_vars` is `True`. Raises: VarnameRetrievingError: When we are unable to retrieve the ast node for the variable(s) and `raise_exc` is set to `True`. ImproperUseError: When the use of `varname()` is improper, including: - When LHS is not an `ast.Name` or `ast.Attribute` node or not a list/tuple of them - When there are multiple variables on LHS but `multi_vars` is False - When `strict` is True, but the result is not assigned to variable(s) directly Note that `raise_exc=False` will NOT suppress this exception. MultiTargetAssignmentWarning: When there are multiple target in the assign node. (e.g: `a = b = func()`, in such a case, `a == 'b'`, may not be the case you want) \"\"\" # Skip one more frame, as it is supposed to be called # inside another function refnode = get_node ( frame + 1 , ignore , raise_exc = raise_exc ) if not refnode : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the ast node.\" ) return None node = lookfor_parent_assign ( refnode , strict = strict ) if not node : # improper use if strict : msg = \"Caller doesn't assign the result directly to variable(s).\" else : msg = \"Expression is not part of an assignment.\" raise ImproperUseError ( rich_exc_message ( msg , refnode )) if isinstance ( node , ast . Assign ): # Need to actually check that there's just one # give warnings if: a = b = func() if len ( node . targets ) > 1 : warnings . warn ( \"Multiple targets in assignment, variable name \" \"on the very right is used. \" , MultiTargetAssignmentWarning , ) target = node . targets [ - 1 ] else : target = node . target names = node_name ( target ) if not isinstance ( names , tuple ): names = ( names ,) if multi_vars : return names if len ( names ) > 1 : raise ImproperUseError ( rich_exc_message ( \"Expect a single variable on left-hand side, \" f \"got { len ( names ) } .\" , refnode , ) ) return names [ 0 ] def will ( frame : int = 1 , raise_exc : bool = True ) -> str : DOCS \"\"\"Detect the attribute name right immediately after a function call. Examples: >>> class AwesomeClass: >>> def __init__(self): >>> self.will = None >>> def permit(self): >>> self.will = will() >>> if self.will == 'do': >>> # let self handle do >>> return self >>> raise AttributeError( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do(self): >>> if self.will != 'do': >>> raise AttributeError(\"You don't have permission to do\") >>> return 'I am doing!' >>> awesome = AwesomeClass() >>> # AttributeError: You don't have permission to do >>> awesome.do() >>> # AttributeError: Should do something with AwesomeClass object >>> awesome.permit() >>> awesome.permit().do() == 'I am doing!' Args: frame: At which frame this function is called. raise_exc: Raise exception we failed to detect the ast node This will NOT supress the `ImproperUseError` Returns: The attribute name right after the function call. `None` if ast node cannot be retrieved and `raise_exc` is `False` Raises: VarnameRetrievingError: When `raise_exc` is `True` and we failed to detect the attribute name (including not having one) ImproperUseError: When (the wraper of) this function is not called inside a method/property of a class instance. Note that this exception will not be suppressed by `raise_exc=False` \"\"\" node = get_node ( frame + 1 , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the frame.\" ) return None # try to get node inst.attr from inst.attr() node = node . parent # see test_will_fail if not isinstance ( node , ast . Attribute ): if raise_exc : raise ImproperUseError ( \"Function `will` has to be called within \" \"a method/property of a class.\" ) return None # ast.Attribute return node . attr def nameof ( DOCS var , # pylint: disable=unused-argument * more_vars , # *, keyword only argument, supported with python3.8+ frame : int = 1 , vars_only : bool = True , ) -> Union [ str , Tuple [ str , ... ]]: \"\"\"Get the names of the variables passed in Examples: >>> a = 1 >>> nameof(a) # 'a' >>> b = 2 >>> nameof(a, b) # ('a', 'b') >>> x = lambda: None >>> x.y = 1 >>> nameof(x.y, full=True) # 'x.y' Note: This function works with the environments where source code is available, in other words, the callee's node can be retrieved by `executing`. In some cases, for example, running code from python shell/REPL or from `exec`/`eval`, we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Args: var: The variable to retrieve the name of *more_vars: Other variables to retrieve the names of frame: The this function is called from the wrapper of it. `frame=1` means no wrappers. Note that the calls from standard libraries are ignored. Also note that the wrapper has to have signature as this one. vars_only: Whether only allow variables/attributes as arguments or any expressions. If `True`, then the sources of the arguments will be returned. Returns: The names/sources of variables/expressions passed in. If a single argument is passed, return the name/source of it. If multiple variables are passed, return a tuple of their names/sources. If the argument is an attribute (e.g. `a.b`) and `vars_only` is `False`, only `\"b\"` will returned. Set `vars_only` to `True` to get `\"a.b\"`. Raises: VarnameRetrievingError: When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. \"\"\" # Frame is anyway used in get_node frameobj = IgnoreList . create ( ignore_lambda = False , ignore_varname = False , ) . get_frame ( frame ) node = get_node_by_frame ( frameobj , raise_exc = True ) if not node : # We can't retrieve the node by executing. # It can be due to running code from python/shell, exec/eval or # other environments where sourcecode cannot be reached # make sure we keep it simple (only single variable passed and no # full passed) to use bytecode_nameof # # We don't have to check keyword arguments here, as the instruction # will then be CALL_FUNCTION_KW. if not more_vars : return bytecode_nameof ( frameobj . f_code , frameobj . f_lasti ) # We are anyway raising exceptions, no worries about additional burden # of frame retrieval again source = frameobj . f_code . co_filename if source == \"<stdin>\" : raise VarnameRetrievingError ( \"Are you trying to call nameof in REPL/python shell? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) if source == \"<string>\" : raise VarnameRetrievingError ( \"Are you trying to call nameof from exec/eval? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) raise VarnameRetrievingError ( \"Source code unavailable, nameof can only retrieve the name of \" \"a single variable, and argument `full` should not be specified.\" ) out = argname ( \"var\" , \"*more_vars\" , func = nameof , frame = frame , vars_only = vars_only , ) return out if more_vars else out [ 0 ] # type: ignore def argname ( # pylint: disable=too-many-branches DOCS arg : str , * more_args : str , # *, keyword-only argument, only available with python3.8+ func : Callable = None , dispatch : Type = None , frame : int = 1 , ignore : IgnoreType = None , vars_only : bool = True , ) -> ArgSourceType : \"\"\"Get the names/sources of arguments passed to a function. Instead of passing the argument variables themselves to this function (like `argname()` does), you should pass their names instead. Args: arg: and *more_args: The names of the arguments that you want to retrieve names/sources of. You can also use subscripts to get parts of the results. >>> def func(*args, **kwargs): >>> return argname2('args[0]', 'kwargs[x]') # no quote needed Star argument is also allowed: >>> def func(*args, x = 1): >>> return argname2('*args', 'x') >>> a = b = c = 1 >>> func(a, b, x=c) # ('a', 'b', 'c') Note the difference: >>> def func(*args, x = 1): >>> return argname2('args', 'x') >>> a = b = c = 1 >>> func(a, b, x=c) # (('a', 'b'), 'c') func: The target function. If not provided, the AST node of the function call will be used to fetch the function: - If a variable (ast.Name) used as function, the `node.id` will be used to get the function from `locals()` or `globals()`. - If variable (ast.Name), attributes (ast.Attribute), subscripts (ast.Subscript), and combinations of those and literals used as function, `pure_eval` will be used to evaluate the node - If `pure_eval` is not installed or failed to evaluate, `eval` will be used. A warning will be shown since unwanted side effects may happen in this case. You are very encouraged to always pass the function explicitly. dispatch: If a function is a single-dispatched function, you can specify a type for it to dispatch the real function. If this is specified, expect `func` to be the generic function if provided. frame: The frame where target function is called from this call. Calls from python standard libraries are ignored. ignore: The intermediate calls to be ignored. See `varname.ignore` vars_only: Require the arguments to be variables only. If False, `asttokens` is required to retrieve the source. Returns: The argument source when no more_args passed, otherwise a tuple of argument sources Raises: VarnameRetrievingError: When the ast node where the function is called cannot be retrieved \"\"\" ignore_list = IgnoreList . create ( ignore , ignore_lambda = False , ignore_varname = False , ) # where func(...) is called, skip the argname2() call func_frame = ignore_list . get_frame ( frame + 1 ) func_node = get_node_by_frame ( func_frame ) # Only do it when func_node are available if not func_node : # We can do something at bytecode level, when a single positional # argument passed to both functions (argname and the target function) # However, it's hard to ensure that there is only a single positional # arguments passed to the target function, at bytecode level. raise VarnameRetrievingError ( \"Cannot retrieve the node where the function is called.\" ) if not func : func = get_function_called_argname ( func_frame , func_node ) if dispatch : func = func . dispatch ( dispatch ) # don't pass the target arguments so that we can cache the sources in # the same call. For example: # >>> def func(a, b): # >>> a_name = argname(a) # >>> b_name = argname(b) try : argument_sources = get_argument_sources ( Source . for_frame ( func_frame ), func_node , func , vars_only = vars_only , ) except Exception as err : # pragma: no cover # find a test case? raise VarnameRetrievingError ( \"Have you specified the right `frame`?\" ) from err out = [] # type: List[ArgSourceType] farg_star = False for farg in ( arg , * more_args ): farg_name = farg farg_subscript = None # type: str | int match = re . match ( r \"^([\\w_]+)\\[(.+)\\]$\" , farg ) if match : farg_name = match . group ( 1 ) farg_subscript = match . group ( 2 ) if farg_subscript . isdigit (): farg_subscript = int ( farg_subscript ) else : match = re . match ( r \"^\\*([\\w_]+)$\" , farg ) if match : farg_name = match . group ( 1 ) farg_star = True if farg_name not in argument_sources : raise ImproperUseError ( f \" { farg_name !r} is not a valid argument \" f \"of { func . __qualname__ !r} .\" ) source = argument_sources [ farg_name ] if isinstance ( source , ast . AST ): raise ImproperUseError ( f \"Argument { ast . dump ( source ) } is not a variable \" \"or an attribute.\" ) if isinstance ( farg_subscript , int ) and not isinstance ( source , tuple ): raise ImproperUseError ( f \"` { farg_name } ` is not a positional argument.\" ) if isinstance ( farg_subscript , str ) and not isinstance ( source , dict ): raise ImproperUseError ( f \"` { farg_name } ` is not a keyword argument.\" ) if farg_subscript is not None : out . append ( source [ farg_subscript ]) # type: ignore elif farg_star : out . extend ( source ) else : out . append ( source ) return ( out [ 0 ] if not more_args and not farg_star else tuple ( out ) # type: ignore ) def argname2 ( DOCS arg : str , * more_args : str , # *, keyword-only argument, only available with python3.8+ func : Callable = None , dispatch : Type = None , frame : int = 1 , ignore : IgnoreType = None , vars_only : bool = True , ) -> ArgSourceType : \"\"\"Alias of argname, will be removed in v0.9.0\"\"\" warnings . warn ( \"`argname2()` is deprecated and will be removed in v0.9.0. \" \"Use `argname()` instead.\" , DeprecationWarning ) return argname ( arg , * more_args , func = func , dispatch = dispatch , frame = frame + 1 , ignore = ignore , vars_only = vars_only , )","title":"varname.core"},{"location":"api/source/varname.helpers/","text":"SOURCE CODE varname. helpers DOCS \"\"\"Some helper functions builtin based upon core features\"\"\" import inspect from functools import partial , wraps from typing import Any , Callable , Type , Union from .utils import IgnoreType from .core import argname , varname def register ( DOCS cls_or_func : type = None , # *, keyword-only argument, only available with python3.8+ frame : int = 1 , ignore : IgnoreType = None , multi_vars : bool = False , raise_exc : bool = True , strict : bool = True , ) -> Union [ Type , Callable ]: \"\"\"A decorator to register __varname__ to a class or function When registered to a class, it can be accessed by `self.__varname__`; while to a function, it is registered to globals, meaning that it can be accessed directly. Args: frame: The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars: Whether allow multiple variables on left-hand side (LHS). If `True`, this function returns a tuple of the variable names, even there is only one variable on LHS. If `False`, and multiple variables on LHS, a `VarnameRetrievingError` will be raised. raise_exc: Whether we should raise an exception if failed to retrieve the name. strict: Whether to only return the variable name if the result of the call is assigned to it directly. Examples: >>> @varname.register >>> class Foo: pass >>> foo = Foo() >>> # foo.__varname__ == 'foo' >>> >>> @varname.register >>> def func(): >>> return __varname__ >>> foo = func() # foo == 'foo' Returns: The wrapper function or the class/function itself if it is specified explictly. \"\"\" if inspect . isclass ( cls_or_func ): orig_init = cls_or_func . __init__ # type: ignore @wraps ( cls_or_func . __init__ ) # type: ignore def wrapped_init ( self , * args , ** kwargs ): \"\"\"Wrapped init function to replace the original one\"\"\" self . __varname__ = varname ( frame - 1 , ignore = ignore , multi_vars = multi_vars , raise_exc = raise_exc , strict = strict , ) orig_init ( self , * args , ** kwargs ) cls_or_func . __init__ = wrapped_init # type: ignore return cls_or_func if inspect . isfunction ( cls_or_func ): @wraps ( cls_or_func ) def wrapper ( * args , ** kwargs ): \"\"\"The wrapper to register `__varname__` to a function\"\"\" cls_or_func . __globals__ [ \"__varname__\" ] = varname ( frame - 1 , ignore = ignore , multi_vars = multi_vars , raise_exc = raise_exc , strict = strict , ) try : return cls_or_func ( * args , ** kwargs ) finally : del cls_or_func . __globals__ [ \"__varname__\" ] return wrapper # None, meaning we have other arguments return partial ( register , frame = frame , ignore = ignore , multi_vars = multi_vars , raise_exc = raise_exc , strict = strict , ) class Wrapper : DOCS \"\"\"A wrapper with ability to retrieve the variable name Examples: >>> foo = Wrapper(True) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper(val) >>> # bar.name == 'bar' >>> # bar.value is val Args: value: The value to be wrapped raise_exc: Whether to raise exception when varname is failed to retrieve strict: Whether to only return the variable name if the wrapper is assigned to it directly. Attributes: name: The variable name to which the instance is assigned value: The value this wrapper wraps \"\"\" def __init__ ( self , value : Any , frame : int = 1 , ignore : IgnoreType = None , raise_exc : bool = True , strict : bool = True , ): # This call is ignored, since it's inside varname self . name = varname ( frame = frame - 1 , ignore = ignore , raise_exc = raise_exc , strict = strict , ) self . value = value def __str__ ( self ) -> str : return repr ( self . value ) def __repr__ ( self ) -> str : return ( f \"< { self . __class__ . __name__ } \" f \"(name= { self . name !r} , value= { self . value !r} )>\" ) def debug ( DOCS var , * more_vars , prefix : str = \"DEBUG: \" , merge : bool = False , repr : bool = True , # pylint: disable=redefined-builtin sep : str = \"=\" , vars_only : bool = False , ) -> None : \"\"\"Print variable names and values. Examples: >>> a = 1 >>> b = object >>> print(f'a={a}') # previously, we have to do >>> print(f'{a=}') # or with python3.8 >>> # instead we can do: >>> debug(a) # DEBUG: a=1 >>> debug(a, prefix='') # a=1 >>> debug(a, b, merge=True) # a=1, b=<object object at 0x2b9a4c89cf00> Args: var: The variable to print *more_vars: Other variables to print prefix: A prefix to print for each line merge: Whether merge all variables in one line or not sep: The separator between the variable name and value repr: Print the value as `repr(var)`? otherwise `str(var)` \"\"\" var_names = argname ( \"var\" , \"*more_vars\" , vars_only = vars_only , func = debug ) values = ( var , * more_vars ) name_and_values = [ f \" { var_name }{ sep }{ value !r} \" if repr else f \" { var_name }{ sep }{ value } \" for var_name , value in zip ( var_names , values ) # type: ignore ] if merge : print ( f \" { prefix }{ ', ' . join ( name_and_values ) } \" ) else : for name_and_value in name_and_values : print ( f \" { prefix }{ name_and_value } \" )","title":"varname.helpers"},{"location":"api/source/varname.ignore/","text":"SOURCE CODE varname. ignore DOCS \"\"\"The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. 1. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by `exec` without module available. 2. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. 3. Ignore frames by a (non-decorated) function. 4. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in `varname`, standard libraries, and frames of any expressions like <lambda> are ignored by default. \"\"\" import sys import inspect from distutils import sysconfig import warnings from os import path from pathlib import Path from fnmatch import fnmatch from abc import ABC , abstractmethod from typing import List , Union from types import FrameType , ModuleType , FunctionType from executing import Source from .utils import ( IgnoreElemType , IgnoreType , MaybeDecoratedFunctionWarning , cached_getmodule , attach_ignore_id_to_module , frame_matches_module_by_ignore_id , check_qualname_by_source , debug_ignore_frame , ) class IgnoreElem ( ABC ): DOCS \"\"\"An element of the ignore list\"\"\" def __init_subclass__ ( cls , attrs : List [ str ]) -> None : DOCS \"\"\"Define different attributes for subclasses\"\"\" def subclass_init ( self , # IgnoreModule: ModuleType # IgnoreFilename/IgnoreDirname: str # IgnoreFunction: FunctionType # IgnoreDecorated: FunctionType, int # IgnoreModuleQualname/IgnoreFilenameQualname: # ModuleType/str, str # IgnoreOnlyQualname: None, str * ign_args : Union [ str , int , ModuleType , FunctionType ], ) -> None : \"\"\"__init__ function for subclasses\"\"\" for attr , arg in zip ( attrs , ign_args ): setattr ( self , attr , arg ) self . _post_init () # save it for __repr__ cls . attrs = attrs cls . __init__ = subclass_init # type: ignore def _post_init ( self ) -> None : \"\"\"Setups after __init__\"\"\" @abstractmethod DOCS def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : \"\"\"Whether the frame matches the ignore element\"\"\" def __repr__ ( self ) -> str : DOCS \"\"\"Representation of the element\"\"\" attr_values = ( getattr ( self , attr ) for attr in self . __class__ . attrs ) # get __name__ if possible attr_values = ( repr ( getattr ( attr_value , \"__name__\" , attr_value )) for attr_value in attr_values ) attr_values = \", \" . join ( attr_values ) return f \" { self . __class__ . __name__ } ( { attr_values } )\" class IgnoreModule ( IgnoreElem , attrs = [ \"module\" ]): DOCS \"\"\"Ignore calls from a module or its submodules\"\"\" def _post_init ( self ) -> None : attach_ignore_id_to_module ( self . module ) def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame module = cached_getmodule ( frame . f_code ) if module : return ( module . __name__ == self . module . __name__ or module . __name__ . startswith ( f \" { self . module . __name__ } .\" ) ) return frame_matches_module_by_ignore_id ( frame , self . module ) class IgnoreFilename ( IgnoreElem , attrs = [ \"filename\" ]): \"\"\"Ignore calls from a module by matching its filename\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame # in case of symbolic links return path . realpath ( frame . f_code . co_filename ) == path . realpath ( self . filename ) class IgnoreDirname ( IgnoreElem , attrs = [ \"dirname\" ]): \"\"\"Ignore calls from modules inside a directory Currently used internally to ignore calls from standard libraries.\"\"\" def _post_init ( self ) -> None : # pylint: disable=access-member-before-definition # pylint: disable=attribute-defined-outside-init # Path object will turn into str here self . dirname = path . realpath ( self . dirname ) # type: str if not self . dirname . endswith ( path . sep ): self . dirname = f \" { self . dirname }{ path . sep } \" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame filename = path . realpath ( frame . f_code . co_filename ) return filename . startswith ( self . dirname ) class IgnoreStdlib ( IgnoreDirname , attrs = [ \"dirname\" ]): \"\"\"Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True) But we need to ignore 3rd-party packages under site-packages/. \"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame third_party_lib = f \" { self . dirname } site-packages { path . sep } \" filename = path . realpath ( frame . f_code . co_filename ) return ( filename . startswith ( self . dirname ) and # Exclude 3rd-party libraries in site-packages not filename . startswith ( third_party_lib ) ) class IgnoreFunction ( IgnoreElem , attrs = [ \"func\" ]): \"\"\"Ignore a non-decorated function\"\"\" def _post_init ( self ) -> None : if ( # without functools.wraps \"<locals>\" in self . func . __qualname__ or self . func . __name__ != self . func . __code__ . co_name ): warnings . warn ( f \"You asked varname to ignore function { self . func . __name__ !r} , \" \"which may be decorated. If it is not intended, you may need \" \"to ignore all intermediate frames with a tuple of \" \"the function and the number of its decorators.\" , MaybeDecoratedFunctionWarning , ) def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame return frame . f_code == self . func . __code__ class IgnoreDecorated ( IgnoreElem , attrs = [ \"func\" , \"n_decor\" ]): \"\"\"Ignore a decorated function\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : try : frame = frameinfos [ frame_no + self . n_decor ] . frame except IndexError : return False return frame . f_code == self . func . __code__ class IgnoreModuleQualname ( IgnoreElem , attrs = [ \"module\" , \"qualname\" ]): \"\"\"Ignore calls by qualified name in the module\"\"\" def _post_init ( self ) -> None : attach_ignore_id_to_module ( self . module ) # check uniqueness of qualname modfile = getattr ( self . module , \"__file__\" , None ) if modfile is not None : check_qualname_by_source ( Source . for_filename ( modfile , self . module . __dict__ ), self . module . __name__ , self . qualname , ) def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame module = cached_getmodule ( frame . f_code ) # Return earlier to avoid qualname uniqueness check if module and module != self . module : return False if not module and not frame_matches_module_by_ignore_id ( frame , self . module ): return False source = Source . for_frame ( frame ) check_qualname_by_source ( source , self . module . __name__ , self . qualname ) return fnmatch ( source . code_qualname ( frame . f_code ), self . qualname ) class IgnoreFilenameQualname ( IgnoreElem , attrs = [ \"filename\" , \"qualname\" ]): \"\"\"Ignore calls with given qualname in the module with the filename\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame frame_filename = path . realpath ( frame . f_code . co_filename ) preset_filename = path . realpath ( self . filename ) # return earlier to avoid qualname uniqueness check if frame_filename != preset_filename : return False source = Source . for_frame ( frame ) check_qualname_by_source ( source , self . filename , self . qualname ) return fnmatch ( source . code_qualname ( frame . f_code ), self . qualname ) class IgnoreOnlyQualname ( IgnoreElem , attrs = [ \"_none\" , \"qualname\" ]): \"\"\"Ignore calls that match the given qualname, across all frames.\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame # module is None, check qualname only return fnmatch ( Source . for_frame ( frame ) . code_qualname ( frame . f_code ), self . qualname ) def create_ignore_elem ( ignore_elem : IgnoreElemType ) -> IgnoreElem : \"\"\"Create an ignore element according to the type\"\"\" if isinstance ( ignore_elem , ModuleType ): return IgnoreModule ( ignore_elem ) # type: ignore if isinstance ( ignore_elem , ( Path , str )): return ( IgnoreDirname ( ignore_elem ) # type: ignore if path . isdir ( ignore_elem ) else IgnoreFilename ( ignore_elem ) # type: ignore ) if hasattr ( ignore_elem , \"__code__\" ): return IgnoreFunction ( ignore_elem ) # type: ignore if not isinstance ( ignore_elem , tuple ) or len ( ignore_elem ) != 2 : raise ValueError ( f \"Unexpected ignore item: { ignore_elem !r} \" ) # is tuple and len == 2 if hasattr ( ignore_elem [ 0 ], \"__code__\" ) and isinstance ( ignore_elem [ 1 ], int ): return IgnoreDecorated ( * ignore_elem ) # type: ignore # otherwise, the second element should be qualname if not isinstance ( ignore_elem [ 1 ], str ): raise ValueError ( f \"Unexpected ignore item: { ignore_elem !r} \" ) if isinstance ( ignore_elem [ 0 ], ModuleType ): return IgnoreModuleQualname ( * ignore_elem ) # type: ignore if isinstance ( ignore_elem [ 0 ], ( Path , str )): return IgnoreFilenameQualname ( * ignore_elem ) # type: ignore if ignore_elem [ 0 ] is None : return IgnoreOnlyQualname ( * ignore_elem ) raise ValueError ( f \"Unexpected ignore item: { ignore_elem !r} \" ) class IgnoreList : \"\"\"The ignore list to match the frames to see if they should be ignored\"\"\" @classmethod def create ( cls , ignore : IgnoreType = None , ignore_lambda : bool = True , ignore_varname : bool = True , ) -> \"IgnoreList\" : \"\"\"Create an IgnoreList object Args: ignore: An element of the ignore list, either A module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators ignore_lambda: whether ignore lambda functions ignore_varname: whether the calls from this package Returns: The IgnoreList object \"\"\" ignore = ignore or [] if not isinstance ( ignore , list ): ignore = [ ignore ] ignore_list = [ IgnoreStdlib ( # type: ignore sysconfig . get_python_lib ( standard_lib = True ) ) ] # type: List[IgnoreElem] if ignore_varname : ignore_list . append ( create_ignore_elem ( sys . modules [ __package__ ])) if ignore_lambda : ignore_list . append ( create_ignore_elem (( None , \"*<lambda>\" ))) for ignore_elem in ignore : ignore_list . append ( create_ignore_elem ( ignore_elem )) return cls ( ignore_list ) # type: ignore def __init__ ( self , ignore_list : List [ IgnoreElemType ]) -> None : self . ignore_list = ignore_list debug_ignore_frame ( \">>> IgnoreList initiated <<<\" ) def nextframe_to_check ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ] ) -> int : \"\"\"Find the next frame to check In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next `ignore[1]`th frame. Args: frame_no: The index of current frame to check frameinfos: The frame info objects Returns: A number for Next `N`th frame to check. 0 if no frame matched. \"\"\" for ignore_elem in self . ignore_list : matched = ignore_elem . match ( frame_no , frameinfos ) # type: ignore if matched and isinstance ( ignore_elem , IgnoreDecorated ): debug_ignore_frame ( f \"Ignored by { ignore_elem !r} \" , frameinfos [ frame_no ] ) return ignore_elem . n_decor + 1 if matched : debug_ignore_frame ( f \"Ignored by { ignore_elem !r} \" , frameinfos [ frame_no ] ) return 1 return 0 def get_frame ( self , frame_no : int ) -> FrameType : \"\"\"Get the right frame by the frame number Args: frame_no: The index of the frame to get Returns: The desired frame Raises: VarnameRetrievingError: if any exceptions raised during the process. \"\"\" try : # since this function will be called by APIs # so we should skip that frames = inspect . getouterframes ( sys . _getframe ( 2 ), 0 ) i = 0 while i < len ( frames ): nextframe = self . nextframe_to_check ( i , frames ) # ignored if nextframe > 0 : i += nextframe continue frame_no -= 1 if frame_no == 0 : debug_ignore_frame ( \"Gotcha!\" , frames [ i ]) return frames [ i ] . frame debug_ignore_frame ( f \"Skipping ( { frame_no - 1 } more to skip)\" , frames [ i ] ) i += 1 except Exception as exc : from .utils import VarnameRetrievingError raise VarnameRetrievingError from exc return None # pragma: no cover","title":"varname.ignore"},{"location":"api/source/varname/","text":"SOURCE CODE varname DOCS \"\"\"Dark magics about variable names in python\"\"\" # pylint: disable=unused-import from .utils import ( config , VarnameException , VarnameRetrievingError , ImproperUseError , QualnameNonUniqueError , VarnameWarning , MultiTargetAssignmentWarning , MaybeDecoratedFunctionWarning , UsingExecWarning , ) from .core import varname , nameof , will , argname , argname2 __version__ = \"0.8.1\"","title":"varname"},{"location":"api/source/varname.utils/","text":"SOURCE CODE varname. utils DOCS \"\"\"Some internal utilities for varname Attributes: IgnoreElemType: The type for ignore elements IgnoreType: The type for the ignore argument MODULE_IGNORE_ID_NAME: The name of the ignore id injected to the module. Espectially for modules that can't be retrieved by `inspect.getmodule(frame)` \"\"\" import sys import dis import ast import warnings import inspect from os import path from pathlib import Path from functools import lru_cache from types import ModuleType , FunctionType , CodeType , FrameType from typing import Tuple , Union , List , Mapping , Callable from executing import Source IgnoreElemType = Union [ # module ModuleType , # filename of a module str , Path , FunctionType , # the module (filename) and qualname # If module is None, then all qualname matches the 2nd element # will be ignored. Used to ignore <lambda> internally Tuple [ Union [ ModuleType , str ], str ], # Function and number of its decorators Tuple [ FunctionType , int ], ] IgnoreType = Union [ IgnoreElemType , List [ IgnoreElemType ]] ArgSourceType = Union [ ast . AST , str ] ArgSourceType = Union [ ArgSourceType , Tuple [ ArgSourceType , ... ]] ArgSourceType = Union [ ArgSourceType , Mapping [ str , ArgSourceType ]] if sys . version_info >= ( 3 , 8 ): ASSIGN_TYPES = ( ast . Assign , ast . AnnAssign , ast . NamedExpr ) AssignType = Union [ ASSIGN_TYPES ] # type: ignore else : # pragma: no cover ASSIGN_TYPES = ( ast . Assign , ast . AnnAssign ) AssignType = Union [ ASSIGN_TYPES ] # type: ignore MODULE_IGNORE_ID_NAME = \"__varname_ignore_id__\" class config : # pylint: disable=invalid-name DOCS \"\"\"Global configurations for varname Attributes: debug: Show debug information for frames being ignored \"\"\" debug = False class VarnameException ( Exception ): DOCS \"\"\"Root exception for all varname exceptions\"\"\" class VarnameRetrievingError ( VarnameException ): DOCS \"\"\"When failed to retrieve the varname\"\"\" class QualnameNonUniqueError ( VarnameException ): DOCS \"\"\"When a qualified name is used as an ignore element but references to multiple objects in a module\"\"\" class ImproperUseError ( VarnameException ): DOCS \"\"\"When varname() is improperly used\"\"\" class VarnameWarning ( Warning ): DOCS \"\"\"Root warning for all varname warnings\"\"\" class MaybeDecoratedFunctionWarning ( VarnameWarning ): DOCS \"\"\"When a suspecious decorated function used as ignore function directly\"\"\" class MultiTargetAssignmentWarning ( VarnameWarning ): DOCS \"\"\"When varname tries to retrieve variable name in a multi-target assignment\"\"\" class UsingExecWarning ( VarnameWarning ): DOCS \"\"\"When exec is used to retrieve function name for `argname()`\"\"\" @lru_cache () DOCS def cached_getmodule ( codeobj : CodeType ): \"\"\"Cached version of inspect.getmodule\"\"\" return inspect . getmodule ( codeobj ) def get_node ( DOCS frame : int , ignore : IgnoreType = None , raise_exc : bool = True , ignore_lambda : bool = True , ) -> ast . AST : \"\"\"Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge `reticulate`, where only first frame is kept. When the node can not be retrieved, try to return the first statement. \"\"\" from .ignore import IgnoreList ignore = IgnoreList . create ( ignore , ignore_lambda = ignore_lambda ) try : frameobj = ignore . get_frame ( frame ) except VarnameRetrievingError : return None return get_node_by_frame ( frameobj , raise_exc ) def get_node_by_frame ( frame : FrameType , raise_exc : bool = True ) -> ast . AST : DOCS \"\"\"Get the node by frame, raise errors if possible\"\"\" exect = Source . executing ( frame ) if exect . node : # attach the frame for better exception message # (ie. where ImproperUseError happens) exect . node . __frame__ = frame return exect . node if exect . source . text and exect . source . tree and raise_exc : raise VarnameRetrievingError ( \"Couldn't retrieve the call node. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return None def lookfor_parent_assign ( node : ast . AST , strict : bool = True ) -> AssignType : DOCS \"\"\"Look for an ast.Assign node in the parents\"\"\" while hasattr ( node , \"parent\" ): node = node . parent if isinstance ( node , ASSIGN_TYPES ): return node if strict : break return None def node_name ( node : ast . AST ) -> Union [ str , Tuple [ Union [ str , Tuple ], ... ]]: DOCS \"\"\"Get the node node name. Raises ImproperUseError when failed \"\"\" if isinstance ( node , ast . Name ): return node . id if isinstance ( node , ast . Attribute ): return node . attr if isinstance ( node , ( ast . List , ast . Tuple )): return tuple ( node_name ( elem ) for elem in node . elts ) raise ImproperUseError ( f \"Can only get name of a variable or attribute, \" f \"not { ast . dump ( node ) } \" ) @lru_cache () DOCS def bytecode_nameof ( code : CodeType , offset : int ) -> str : \"\"\"Cached Bytecode version of nameof We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with `eval`, or other circumstances where the code is manipulated to run but sourcecode is not available. \"\"\" instructions = list ( dis . get_instructions ( code )) (( current_instruction_index , current_instruction ),) = ( ( index , instruction ) for index , instruction in enumerate ( instructions ) if instruction . offset == offset ) if current_instruction . opname in ( \"CALL_FUNCTION_EX\" , \"CALL_FUNCTION_KW\" ): raise VarnameRetrievingError ( \"'nameof' can only be called with a single positional argument \" \"when source code is not avaiable.\" ) if current_instruction . opname not in ( \"CALL_FUNCTION\" , \"CALL_METHOD\" ): raise VarnameRetrievingError ( \"Did you call 'nameof' in a weird way?\" ) name_instruction = instructions [ current_instruction_index - 1 ] if not name_instruction . opname . startswith ( \"LOAD_\" ): raise VarnameRetrievingError ( \"Argument must be a variable or attribute\" ) name = name_instruction . argrepr if not name . isidentifier (): raise VarnameRetrievingError ( f \"Found the variable name { name !r} which is obviously wrong. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return name def attach_ignore_id_to_module ( module : ModuleType ) -> None : DOCS \"\"\"Attach the ignore id to module This is useful when a module cannot be retrieved by frames using `inspect.getmodule`, then we can use this id, which will exist in `frame.f_globals` to check if the module matches in ignore. Do it only when the __file__ is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and `inspect.getmodule` would not work \"\"\" module_file = getattr ( module , \"__file__\" , None ) if module_file is not None and path . isfile ( module_file ): return # or it's already been set if hasattr ( module , MODULE_IGNORE_ID_NAME ): return setattr ( module , MODULE_IGNORE_ID_NAME , f \"<varname-ignore- { id ( module ) } )\" ) def frame_matches_module_by_ignore_id ( DOCS frame : FrameType , module : ModuleType ) -> bool : \"\"\"Check if the frame is from the module by ignore id\"\"\" ignore_id_attached = getattr ( module , MODULE_IGNORE_ID_NAME , object ()) ignore_id_from_frame = frame . f_globals . get ( MODULE_IGNORE_ID_NAME , object ()) return ignore_id_attached == ignore_id_from_frame @lru_cache () DOCS def check_qualname_by_source ( source : Source , modname : str , qualname : str ) -> None : \"\"\"Check if a qualname in module is unique\"\"\" if not source . tree : # no way to check it, skip return nobj = list ( source . _qualnames . values ()) . count ( qualname ) if nobj > 1 : raise QualnameNonUniqueError ( f \"Qualname { qualname !r} in \" f \" { modname !r} refers to multiple objects.\" ) def debug_ignore_frame ( msg : str , frameinfo : inspect . FrameInfo = None ) -> None : DOCS \"\"\"Print the debug message for a given frame info object Args: msg: The debugging message frameinfo: The FrameInfo object for the frame \"\"\" if not config . debug : return if frameinfo is not None : msg = ( f \" { msg } [In { frameinfo . function !r} at \" f \" { frameinfo . filename } : { frameinfo . lineno } ]\" ) sys . stderr . write ( f \"[ { __package__ } ] DEBUG: { msg } \\n \" ) def argnode_source ( DOCS source : Source , node : ast . AST , vars_only : bool ) -> Union [ str , ast . AST ]: \"\"\"Get the source of an argument node Args: source: The executing source object node: The node to get the source from vars_only: Whether only allow variables and attributes Returns: The source of the node (node.id for ast.Name, node.attr for ast.Attribute). Or the node itself if the source cannot be fetched. \"\"\" if vars_only : return ( node . id if isinstance ( node , ast . Name ) else node . attr if isinstance ( node , ast . Attribute ) else node ) # requires asttokens return source . asttokens () . get_text ( node ) @lru_cache () DOCS def get_argument_sources ( source : Source , node : ast . Call , func : Callable , vars_only : bool , ) -> Mapping [ str , ArgSourceType ]: \"\"\"Get the sources for argument from an ast.Call node >>> def func(a, b, c, d=4): >>> ... >>> x = y = z = 1 >>> func(y, x, c=z) >>> # argument_sources = {'a': 'y', 'b', 'x', 'c': 'z'} >>> func(y, x, c=1) >>> # argument_sources = {'a': 'y', 'b', 'x', 'c': ast.Num(n=1)} \"\"\" # <Signature (a, b, c, d=4)> signature = inspect . signature ( func , follow_wrapped = False ) # func(y, x, c=z) # ['y', 'x'], {'c': 'z'} arg_sources = [ argnode_source ( source , argnode , vars_only ) for argnode in node . args ] kwarg_sources = { argnode . arg : argnode_source ( source , argnode . value , vars_only ) for argnode in node . keywords if argnode . arg is not None } bound_args = signature . bind_partial ( * arg_sources , ** kwarg_sources ) argument_sources = bound_args . arguments # see if *args and **kwargs have anything assigned # if not, assign () and {} to them for parameter in signature . parameters . values (): if parameter . kind == inspect . Parameter . VAR_POSITIONAL : argument_sources . setdefault ( parameter . name , ()) if parameter . kind == inspect . Parameter . VAR_KEYWORD : argument_sources . setdefault ( parameter . name , {}) return argument_sources def get_function_called_argname ( frame : FrameType , node : ast . AST ) -> Callable : DOCS \"\"\"Get the function who called argname\"\"\" # We need node to be ast.Call if not isinstance ( node , ast . Call ): raise VarnameRetrievingError ( f \"Expect an 'ast.Call' node, but got { type ( node ) !r} . \" \"Are you using 'argname' inside a function?\" ) # variable if isinstance ( node . func , ast . Name ): func = frame . f_locals . get ( node . func . id , frame . f_globals . get ( node . func . id ) ) if func is None : # pragma: no cover # not sure how it would happen but in case raise VarnameRetrievingError ( f \"Cannot retrieve the function by { node . func . id !r} .\" ) return func # use pure_eval pure_eval_fail_msg = None try : from pure_eval import Evaluator , CannotEval except ImportError : pure_eval_fail_msg = \"'pure_eval' is not installed.\" else : try : evaluator = Evaluator . from_frame ( frame ) return evaluator [ node . func ] except CannotEval : pure_eval_fail_msg = ( f \"Cannot evaluate node { ast . dump ( node . func ) } \" \"using 'pure_eval'.\" ) # try eval warnings . warn ( f \" { pure_eval_fail_msg } \" \"Using 'eval' to get the function that calls 'argname'. \" \"Try calling it using a variable reference to the function, or \" \"passing the function to 'argname' explicitly.\" , UsingExecWarning ) expr = ast . Expression ( node . func ) code = compile ( expr , \"<ast-call>\" , \"eval\" ) # pylint: disable=eval-used return eval ( code , frame . f_globals , frame . f_locals ) def rich_exc_message ( msg : str , node : ast . AST , context_lines : int = 4 ) -> str : DOCS \"\"\"Attach the source code from the node to message to get a rich message for exceptions If package 'rich' is not install or 'node.__frame__' doesn't exist, fall to plain message (with basic information), otherwise show a better message with full information \"\"\" frame = node . __frame__ # type: FrameType lineno = node . lineno - 1 # type: int col_offset = node . col_offset # type: int filename = frame . f_code . co_filename # type: str try : lines , startlineno = inspect . getsourcelines ( frame ) except OSError : # pragma: no cover # could not get source code return f \" { msg } \\n \" startlineno = 0 if startlineno == 0 else startlineno - 1 line_range = ( startlineno + 1 , startlineno + len ( lines ) + 1 ) linenos = tuple ( map ( str , range ( * line_range ))) # type: Tuple[str, ...] lineno_width = max ( map ( len , linenos )) # type: int hiline = lineno - startlineno # type: int codes = [] # type: List[str] for i , lno in enumerate ( linenos ): if i < hiline - context_lines or i > hiline + context_lines : continue lno = lno . ljust ( lineno_width ) if i == hiline : codes . append ( f \" > | { lno } { lines [ i ] } \" ) codes . append ( f \" | { ' ' * ( lineno_width + col_offset + 2 ) } ^ \\n \" ) else : codes . append ( f \" | { lno } { lines [ i ] } \" ) return ( f \" { msg } \\n\\n \" f \" { filename } : { lineno + 1 } : { col_offset + 1 } \\n \" f \" { '' . join ( codes ) } \\n \" )","title":"varname.utils"}]}